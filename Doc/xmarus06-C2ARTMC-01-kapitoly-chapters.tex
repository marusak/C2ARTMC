%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Úvod}

\chapter{Nástroj ARTMC}
ARTMC je nástroj na formálnu verifikáciu programov, ktoré manipulujú s
dynamicky viazanými dátovými štruktúrami. Tento nástroj bol vyvinutý na Fakulte
Informatiky Vysokého Učení Technického v Brne vrámci výskumnej skupiny VeriFit,
ktorá sa zaoberá verifikáciou programov. V tejto kapitole je tento nástroj
popísaný z dvoch hľadísk. Najskôr je stručný prehľad funkcionality jazyka a
následne je popísaná štruktúra vstupného súboru, ktorý je pre túto prácu
najdôležitejší.

\section{Funkcionalita a použitie ARTMC}
Majme na vstupe nerekurzívny program, ktorý manipuluje s dynamicky viazanými
šturktúrami s viacnásobnými next ukazateľmi. Snahou nástroja je overiť, že
nemôžu nastať nedovolené operácie (napr. zápis do null ukazateľa, použitie
nedefinovaného alebo už zmazaného prvku atď.).

Verifikačná metóda, ktorá je použitá v tomto nástroji je založená na abstraktom
regulárnom stromovom model checkingu. MORE 

\section{Formát vstupného súboru}
Na vstupu musia byť dva súbory:
1. Typedefs - SOMETHING
2. Zdrojový súbor obsahujúci jednu funkciu v jazyku Python, ktorá
vracia dvojicu \texttt{(program, env)}.
Prvý prvok \textit{program} je zoznam n-tíc, kde každá ntica je jeden príkaz
jazyka ARTMC. V tabuľke \ref{table:prikazy} sú popísané jednotlivé podporované
konštrukcie.
\begin{table}[]
\begin{tabular}{ll}
x:=null             &          ("x=null","line\_num",x,next\_line)\\
x:=y                &  ("x=y","line\_num",x,y,next\_line)\\
x:=y.next           & ("x=y.next","line\_num",x,y,next,next\_line)\\
x.next=y            &("x.next=y","line\_num",x,y,next,next\_line,descr\_num)\\
if x==NULL          &  ("ifx==null",line\_num",x,next\_line\_then,next\_line\_else)\\
if x==y             &     ("ifx==y","line\_num",x,y,next\_line\_then,next\_line\_else)\\
if *                & ("if*","line\_num",next\_line\_then,next\_line\_else)\\
goto                & ("goto","line\_num",next\_line)\\
exit                &   ("exit","line\_num")\\
x.next=null         &      ("x.next=null","line\_num",x,next,next\_line)\\
xnext=new           &  ("x.next=new","line\_num",x,next,next\_line, descr\_num, gen\_descr)\\
setdata             &     ("setdata","line\_num",x,"data",next\_line)\\
if x.data=="..."    &            ("ifdata","line\_num",x,"data",next\_line\_then,next\_line\_else)\\
x:=random\_position  &           ("x=random","line\_num",x,next\_line)\\
new                  &   ("new","line\_num",x,next\_line)\\
\end{tabular}[]
\caption{Podporované príkazy v ARTMC}
\label{table:prikazy}
\end{table}
\subsection{Popis príkazu jazyka pre ARTMC}
\begin{itemize}
    \item[Identifikátor] Prvá položka je vždy reťazec obsahujúci identifikátor inštrukcie.
    \item[Číslo príkazu] Druhá položka značená ako \textit{line\_num} identifikuje príkaz
        vrámci celého programu. Jedná sa o reťazec skladajúci sa z postupnosti
        núl a jedničiek, ktorý musí byť vrámci celého  programu jedinečný.
        Ideálny postup je číslovať inštukcie od 0 až po N a previesť tieto
        čísla do binárnej podoby. Zároveň je dôležité, aby všetky výsledné binárne čísla mali rovnako znakov.
    \item[Premenné] Označené ako \textit{x} a \textit{b}. V programe sú značené prirodzenými číslami.
    \item[Ukazateľové premenné] Označené ako \textit{next}. V programe sú číslované od 0.
    \item[Ukazateľ na dalšiu inštrukciu] Označené ako \textit{next\_line}. Označuje
        číslo riadku inštrukcie, na ktorej sa po skončení bude pokračovať. Inštrukcie
        sú číslované od nuly. Ak je použítá prípona \textit{\_then} alebo \textit{\_else}
        jedná sa o miesto pokračovania v prípade splnenia alebo nesplnenia podmienky danej inštrukcie.
    \item[Deskriptory 1] dunno now
    \item[Desktirpty 2] dunno now
\end{itemize}
\section{Tvorba programu v ARTMC}
Tvorba programu pre nástroj ARTMC je zložitá, ľahko sa v nom tvoria chyby a je zložité
upravovať napísaný program.
Ako príklad uveďme jedoduchý program, ktorý by v jazyku C mohol vyzerǎt nasledovne"

while(x->next != NUll)
    x = x->next;

Takýto program by sa do nástroja artmc prepísal ako
        ("x=y.next","00000000",2,1,0,1),
        ("ifx==null","00000001",2,4,2),
        ("x=y.next","00000010",1,1,0,3),
        ("goto","00000011",0),

Okrem tohoto kódu avšak je potrebné napísať celú triedu, ktorá vracia tento kód.
Teda celý vstupný súbor by vyzeral nasledovne.

Tabulka z toho s vysvetlivkami kazdheo riadku?

def get_program()$\colon$
   program=[
        ("x=y.next","00000000",2,1,0,1),
        ("ifx==null","00000001",2,4,2),
        ("x=y.next","00000010",1,1,0,3),
        ("goto","00000011",0),
        ("exit","00000100")]   # Na konci musí byť inštrukcia exit
    node_width=16111 
    pointer_num=3
    desc_num=3
    next_num=1
    err_line="11111111"
    restrict_var=1

    env=(node_width, pointer_num, desc_num, next_num, err_line,restrict_var)
    return(program, env)

Programátor si ihneď uvedomí ako ľahko sa môžu vyskytnúť chyby, hlavne pri značení
premenných číslom, pri značení miesta skoku atď. Rovnako si určite uvedomí, aká zložitá
je úprava kódu, keď sa pouiva absolútne adresovanie.
Ak by sme sa rozhodli čo i len trochu upraviť testovanú funkciu, znamenalo by to
prepísanie takmer celého kódu.

Ukážka - pridať podmeinku a je to v keli...


\chapter{Prekladače}
Prekladač je nástroj, ktorý číta zdrojový program a prekladá ho na cieľový program.
Zdrojový a cieľový program sú si vzájomne funkčne ekvivalentné. [slidy IFJ Uvod do kompilatorov]
Prekladač pozastáva z viacerých častí. Schéma bežného prekladača je na obrázku 1.
[OBRAZOK 4/17 IFJ Uvod do kompilatorov].

\section{Lexikálny analyzátor}
Lexikálny analyzátor, scanner, má na vstupe zdrojový program. Tento program
rozdeľuje na lexémy - logicky oddelené lexikálne jednotky. Na výstupe je reťazec
tokenov, pričom token reprezentuje lexémy a môže obsahovať ďalšie atribúty.
Pre lepšie porozumenie viď obŕazok OBR1
[Obrazok IFJ 7/17 Uvod do kompilatorov - jednoducheis nieco ako int x = 0;]

\section{Syntaktický analyzátor}
Syntaktický analyzátor, parser, má na vstupe reťazec tokenov, ktoré získal
z lexikalného analyzátora(ref na kapitolu vyssie). Úlohou je skontrolovať, či
reťazec tokenov reprezentuje syntakticky správne napísaný program. Táto kontrola
prebieha za pomoci konštrukcie derivačného stromu. Ak je možné zostrojiť derivačný strom
jedná sa o program validný. Konštrukcia môže prebiehať dvôma spôsobmi a to zhora
nadol a zdola nahor.

\subsection{Analýza zhora-nadol}
TODO
\subsection{Analýza zdola-nahor}
TODO

\section{Sémantický analyzátor}
Na vstupe sémantického analyzátoru je derivačný strom, ktorý bol získaný od
syntaktického analyzátora. Sémantikcý analyzátor kontroluje sémantické aspekty
vstupného programu a to hlavne 
\begin{itemize}
    \item kontrola typov
    \item kontrola deklarácií premmených
\end{itemize}
Na výstupe je abstraktný syntaktický strom.

\section{Generátor vnútorného kódu}
Generátor vnútroneho kódu, ako názov napovedá, vytvára vnútornú reprezentáciu porgramu
z abstraktného sysntaktickeho stromu. Medzi hlavné dôvody, prečo je vhodné
vytvárať vnútroný kód patrí hlavne:
\begin{itemize}
    \item Priame vytváranie výstupného programu je nepriehladné
    \item Jednotnosť - všetky inštrukcie sa tvária rovnako
    \item Jednoduchá optimalizácia
\end{itemize}

\section{Optimalizátor}
Cieľom tejto časti je upraviť vnútrorný kód to takej podoby, aby bol efektívnejší.
Medzi optimalizácie môžu patriť:
\begin{itemize}
    \item Eliminácia mŕtveho kódu
    \item Šírenie kopírovaným
    \item Šírenie konštanty
\end{itemize}

\section{Generovanie cieľového kódu}
Optimalizovaný kód zśiakný z optimalizátora je prevedený na cieLový program.

Syntaxou riadený preklad je ...TODO

\chapter{Súčasný stav prekladača pre ARTMC}
Pre ARTMC bol vytvorený prekladač z jazyka C s názvom AVERILES. Jedná sa o
rekladač napísaný v jazyku Java. Snahou tejto práce nie je tento prekladač
upraviť ale napísať úplne nový. Hlavné dôvody prečo je potrebé vytvoriť nový
prekladač sú:
\begin{itemize}
    \item Chyby v prekladači\\
        Prekladač nedokázal spracovať určité výrazy. Niektoré výrazy prekladal nesprávne.
        Preto bolo potrebné pri zložitejších programoch manuálne kontrolovať výsledný
        program a editovať vstupný rpogram do takej formy, aby ho prekladač dokázal
        preložiť.
    \item Tažko rozšíteľný\\
        Prekladač bol napísaný v jazyku Java dos+t zložitým a nečitateľným spôsobom. Takýto
        kód sa veľmi tažko modifikuje a rozširuje o daľsie vlastnosti. Prekladač,
        ktorý je výstupom tejto práce si dáva za cieľ čitateľný kód, do ktorého
        sa jednoducho dopĺňajú dalšie funkcionality.
    \item Nepraktické používanie\\
        Proces prekladu za pomoci Averlis pozostáva z dvoch krokov
        \begin{enumerate}
            \item Tvorba XML zo zdrojového kódu v C
            \item Preklad XML do ARTMC
        \end{enumerate}
        Takýto postup je zložitejší, nakoľko je potrebné volať dva programy.
        Zároveň programy nemajú prepínače na modifikáciu ich správania. Teda
        ich použitie je možné len v jednom užívateľskom prípade
\end{itemize}


\chapter{Implementácia}
Táto kapitola sa venuje návrhu a implementácii samotného prekladača.
Ako implementačný jazyk bol zvolený python. Kritériá, ktoré by mala výsledná
aplikácia spĺnať sa dajú rozdeliť do dvoch kategórií:
\begin{enumerate}
    \item Použiteľnosť a prenositeľnosť
    \item Moderný vývoj
\end{enumerate}

\section{Použiteľnosť a prenositeľnosť}
Výsledná aplikácia by mala byť jednoducho použiteľná. Tak ako bolo spomenuté v
kapitole XX, momentálne existujúci prekladač ma nie jednoduché použivanie. Zároveň
neumožnuje špecifikovať dalšie voľby, ktoré by uivateľ mohol potrebovať. Voľby,
ktoré by uivateľ mohol potrebovať mimo iné patria hlavne:
\begin{itemize}
    \item Možnosť špecifikovať výstupný súbor\\
        Defaultne výstupný súbor sa uloží na rovnake miesto ako vstupný a je
        pomenovaný \texttt{program.py}. Avšak užívateľ si môže zvoliť ľubovoľné umiestenie
        a názov súboru.
    \item Možnosť špecifikovať vstupný descriptor\\
        Viď kapitola X. Nakoľko sa vstupný descriptor získava z \texttt{getsth} a je
        možné, že tento program nie je dostupný, aby sa dal preklad spustiť, môže
        užívateľ túto hodnotu poskytnúť.
    \item Možnosť ignorácie dát\\
        Nakoľko podpora práce s dátami v ARTMC je výrazne obmedzená, môže byť
        vhodné nechať prekladač aby prácu s dátami neprekladal.
\end{itemize}

Rovnako medzi hlavné požiadavky patrí aj prenositeľnosť. V rámci prenositeľnosti
musíme uvažovať dva druhy:
\begin{itemize}
    \item Operačný systém\\
        Program by mal byť spustieteľný a správne bežať aspoň na Linux-och a Windows-och.
    \item Verzia pythonu\\
        Program by mal byť spustieteľný a správne bežať na všetkých hlavných verziách Pythonu.
        Viac o Pythone a verziách je v kapitole XX.
\end{itemize}

\subsection{Python}
Python je vysokoúrovňový skriptovací programovací jazyk. Podporuje viacero programovacích
paradigmat. Pre túto prácu bude použité objektovo orientované. Zároveň Python podporuje
dynamickú typovú kontrolu. MORE
Python má dve hlavné verzie. Python 2.X a Python 3.X. Dalej tieto verzie sa delia na podverzie.
Verzie a podverzie nemusia (a ani nie sú) medzi sebou kompatibilné. To prináša problém
pre programátorov, ktorý chcú písať program tak, aby fungoval pre rôzne verzie.
C2ARTMC by mal fungovať aspon pre verzie \texttt{2.6, 2.7, 3.3, 3.4, 3.5}.

\section{Moderný vývoj}
Táto časť sa venuje postupom a metódam, ktoré pri vývoji budú použité. Jedná sa
o prevažne o technológie, ktoré určujú kvalitný projekt v dnešnej dobe.

\subsection{Git}
Verzovací systém git umožnuje sledovať vývoj projektu a v jednotlivých zmenách
v histórií sa posúvať. Teda v prípade chyby je jednoduché zistiť kedy a ako chyba
vznikla. Zároveň je jednoduché sa vrátiť do stavu pred chybou.
Git umožnuje rovnako jedoduchú spoluprácu viacerých autorov. Táto práca je
prirodzene dielom jedného autora, avšak je možné, že po dokončení práce sa nájde
chyba, alebo bude treba doplniť funkcionalitu a to umožní aby iný autor túto zmenu
vykonal.
Táto práca vyuiva GitHub a je dostupná na URL.

\subsection{Unittest}
Pri pridávaní novej funkcionality sa môže stať, že sa zavedie chyba vrámci inej
funckionality. Preto je najvhodnejšie, po každej zmene otestovať všetky predtým
naprogramované funkcionality. To je prirodzene takmer nemožné. Preto sa píšu testy,
ktoré sa dajú spúsťat hromadne a je ľahko a rýchlo možné overit, že neprišlo k
zavedeniu chyby.

\subsection{Tox}
Aby bolo možné spúsťat unittesty pod rôznymi verizami pythonu a overiť, že všetky testy
upsejú na všetkých podporvovanćyh verziach pythonu v práci bude použitý nájstroj tox.
Jedná sa o porgram, ktorý potrebuje iba jeden jednoduchý konfiguračný súbor, ktorý
obsahuj spôsob ako sa spúštajú unittesty a verzie pythonov, pod ktorými chceme
aby program fungoval. Následne zavolaním programu tox bez argumentov sa testy
spustia pod všetk=ymi poždaovaními verziami a prehľadny výpis oznámi, či všetky
testy boli úspešné, prípadne ktorý test neuspel v ktorej verzii.

\chapter{Výsledná aplikácia}

\section{Testy}

\section{Nedostatky}

\section{Navrhovaná práca}

\chapter{Záver}

%=========================================================================
