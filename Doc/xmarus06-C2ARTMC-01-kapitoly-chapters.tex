%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Úvod}
Verifikácia programov, teda overovanie že program spĺňa určité požiadavky, je v dnešnej dobe veľmi žiadaná. Napriek záujmu zo strán tvorcov softvéru neexistuje skutočne univerzálne a dokonalé riešenie. Avšak mnoho subjektov vytvára verfikátory, ktoré dokážu kontrolovať určité požadované vlastnosti programov.

Jedným z aktívnych subjektov pre verifikáciu a automatizovanú analýzu je aj výskumná skupina VeriFit na Vysokom Učení Technickom v Brne. Skupina se zabývá základným výzkumom, ale taktiež aj vývojom prototypových verifikačných nástrojov. Jedným z takýchto nástrojov je aj ARTMC.

Cieľom tejto práce je implementovať prekladač, ktorý dokáže z validného programu napísanom v jazyku C vytvoriť validný funkčne rovnaký program pre nástroj ARTMC.

TODO kazdy odsek raz tak dlhy


\chapter{Nástroj ARTMC}
ARTMC je nástroj na formálnu verifikáciu programov, ktoré manipulujú s
dynamicky viazanými dátovými štruktúrami. Tento nástroj bol vyvinutý na Fakulte
Informatiky Vysokého Učení Technického v Brne vrámci výskumnej skupiny VeriFit,
ktorá sa zaoberá verifikáciou programov. V tejto kapitole je tento nástroj
popísaný z dvoch hľadísk. Najskôr je stručný prehľad funkcionality jazyka a
následne je popísaná štruktúra vstupného súboru, ktorý je pre túto prácu
najdôležitejší.

\section{Funkcionalita a použitie ARTMC}
Majme na vstupe nerekurzívny program, ktorý manipuluje s dynamicky viazanými
šturktúrami s viacnásobnými next ukazateľmi. Snahou nástroja je overiť, že
nemôžu nastať nedovolené operácie (napr. zápis do null ukazateľa, použitie
nedefinovaného alebo už zmazaného prvku atď.).

Verifikačná metóda, ktorá je použitá v tomto nástroji je založená na abstraktom
regulárnom stromovom model checkingu. TODO odkaz kde sa o tom najde viac

TODO aspon raz tolko

\section{Formát vstupného súboru}
Nástroj ARTMC potrebuje pre svoju analýzu dva súbory. Jedná sa o súbor \texttt{typedefs}, ktorý obsahuje definíciu množiny počiatočnej konfigurácie a súbor \texttt{program.py} obsahujúci definíciu programu vo formáte vytvorenom pre potreby tohto nástroja.

\subsection{typedefs}
Tento súbor sa používa na špecifikáciu množiny počiatočnej konfigurácie. Súbor obsahuje množinu typov. Následne sa pamäť zostavuje z uzlov špecifikovaných typov, ktore sú prepojené za pomoci selektorov.

Existujú dva druhy selektorov:
\begin{itemize}
\item \textit{Priame spojenia}
\item \textit{Nepriame spojenia} sú popísané za pomoci cesty cez priame spojenia. Za pomoci symbola ``-'' pred priamym spojením sa značí nasledovanie spojenia späť.
\end{itemize}

Súbor typedefs pre obojsmerne viazaný list by mohol vyzerať nasledovne: \textit{(+ znamená \uv{alebo})}

\texttt{
typedef struct Tinit\\                                                            
/*? x ?*/\\                                                                       
\{\\
  struct T2 * next ;\\                                                           
  struct T2 * back ; /*? null ?*/\\                                               
\};\\
                                                                                \\
typedef struct T2                                                           
\{\\
  struct T2 * next ; /*? null ?*/\\                                               
  struct Any * back ; /*? -next ?*/\\
\}
+
\{\\
  struct T2 * next ;\\                                                           
  struct Any * back ; /*? -next ?*/\\                                             
\};
}

\subsection{program.py}
Zdrojový súbor obsahujúci jednu funkciu v jazyku Python, ktorá vracia dvojicu \texttt{(program, env)}.
Prvý prvok \textit{program} je zoznam n-tíc, kde každá ntica je jeden príkaz jazyka ARTMC. V tabuľke \ref{table:prikazy} sú popísané jednotlivé podporované konštrukcie.
\begin{table}[]
\begin{tabular}{ll}
x:=null             & (``x=null'',``line\_num'',x,next\_line)\\
x:=y                & (``x=y'',``line\_num'',x,y,next\_line)\\
x:=y.next           & (``x=y.next'',``line\_num'',x,y,next,next\_line)\\
x.next=y            & (``x.next=y'',``line\_num'',x,y,next,next\_line,descr\_num)\\
if x==NULL          & (``ifx==null'',``line\_num'',x,next\_line\_then,next\_line\_else)\\
if x==y             & (``ifx==y'',``line\_num'',x,y,next\_line\_then,next\_line\_else)\\
if *                & (``if*'',``line\_num'',next\_line\_then,next\_line\_else)\\
goto                & (``goto'',``line\_num'',next\_line)\\
exit                & (``exit'',``line\_num'')\\
x.next=null         & (``x.next=null'',``line\_num'',x,next,next\_line)\\
x.next=new           & (``x.next=new'',``line\_num'',x,next,next\_line, descr\_num, gen\_descr)\\
setdata             & (``setdata'',``line\_num",x,``data'',next\_line)\\
if x.data==``\dots'' & (``ifdata'',``line\_num'',x,``data'',next\_line\_then,next\_line\_else)\\
x:=random\_position & (``x=random'',``line\_num'',x,next\_line)\\
new                 & (``new'',``line\_num'',x,next\_line)\\
\end{tabular}[]
\caption{Podporované príkazy v ARTMC}
\label{table:prikazy}
\end{table}
\subsection{Popis príkazov jazyka pre ARTMC}
\begin{itemize}
    \item \textit{Identifikátor} - Prvá položka je vždy reťazec obsahujúci identifikátor inštrukcie.
    \item \textit{Číslo príkazu} - Druhá položka značená ako \textit{line\_num} identifikuje príkaz
        vrámci celého programu. Jedná sa o reťazec skladajúci sa z postupnosti
        núl a jedničiek, ktorý musí byť vrámci celého  programu jedinečný.
        Ideálny postup je číslovať inštukcie od 0 až po N a previesť tieto
        čísla do binárnej podoby. Zároveň je dôležité, aby všetky výsledné binárne čísla mali rovnako znakov.
    \item \textit{Premenné} - Označené ako \textit{x} a \textit{b}. V programe sú značené prirodzenými číslami.
    \item \textit{Ukazateľové premenné} - Označené ako \textit{next}. V programe sú číslované od 0.
    \item \textit{Ukazateľ na dalšiu inštrukciu} - Označené ako \textit{next\_line}. Označuje
        číslo riadku inštrukcie, na ktorej sa po skončení bude pokračovať. Inštrukcie
        sú číslované od nuly. Ak je použítá prípona \textit{\_then} alebo \textit{\_else}
        jedná sa o miesto pokračovania v prípade splnenia alebo nesplnenia podmienky danej inštrukcie.
    \item \textit{Deskriptory 1} - Označené ako \textit{descr\_num}. Jedinečný deskriptor použitý pri vykonávani danej inštrukcie. Deskriptory sú číslované od 1. Viac o nastavovaní hodnôt tohto deskriptoru je v TODO ref.
    \item \textit{Desktirpty 2} - Označené ako \textit{gen\_num}. Využíva sa iba pri príkaze \texttt{x.next=new} a označuje automatickú generáciu počiatočného deskriptoru. Nadobúda hodnoty 0 (vypnuté) a 1 (zapnuté).
\end{itemize}

\subsection{env}
Jedná sa o 6ticu \texttt{node\_width, pointer\_num, desc\_num, next\_num, err\_line, restrict\_var} obsahujúcu informácie o programe.
Význam jednotlivých položiek je uvedený v TODO ref

\begin{itemize}
\item \texttt{node\_width = pointer\_num + descr\_num + 2 + } šírka dát  
\item \texttt{pointer\_num} = Počet ukazateľových premenných zvýšený o 1
\item \texttt{desc\_num} = Počet ukazateľových deskriptorov zvýšený o 1. TODO ref NAstavovnaide desktiptoru
\item \texttt{next\_num} = Počet next pointerov použitých v programe
\item \texttt{err\_line} = Označenie riadku, na ktorý sa skáče v prípade chyby.
\item \texttt{restrict\_var} = Automatické generovanie automatu, ktorý garantuje iba jeden výskyt programovej premennej v konfigurácii. Nadobúda hodnoty 0 (vypnuté) a 1 (zapnuté).
\end{itemize}


\subsection{Nastavovanie deskriptoru}
Deskriptor pozostáva z dvoch častí:
\begin{enumerate}
\item Deskriptory v konfigurácii - Jedná sa o deskriptory, ktoré sú použité v súbore \textit{typedefs}. Tieto deskriptory už nemôžu byť znova použité. Číslo najvyššieho použitého deskriptoru je možné získať zo skriptu \texttt{get\_typedef\_descr.t.sh}, ktorý je šírení v distribúcii ARTMC.
\item Vlastné deskriptory - Každý príkaz typu \texttt{x.next=y} alebo \texttt{x.next=new} dostane vlastný deskriptor, ktorý ešte nebol použitý. Nemôže byť použitý ani v konfigurácii.
\end{enumerate}

\subsection{Podpora práce s dátami v ARTMC}
Jazyk pre nástroj ARTMC obsahuje iba dve inštrukcie pre prácu s dátami. Jedná sa o príkazy \texttt{setdata} a \texttt{ifdata}. Existujú teda iba funkcie na priradenie hodnoty a na porovanie hodnoty. Ako si je možné v tabuľke TODO ref všímnúť, tieto funkcie berú iba jednú premennú \texttt{x}. Je to preto, lebo sa predpokladá, že štruktúra, ktorej je premenná \texttt{x} má práve jednu dátovú položku. V jazyku C môžu tieto dáta byť ľubovoľného typu, avšak pre ARTMC musia byť kódované ako postupnosť núl a jedničiek. Na skutočnej reprezentácii v binárnej podobe nezáleží, tak je napríklad vhodné prvým dátam dať napr. 	``00000001'' ďalším ``00000010'' atď. Je len potrebné aby rovnaká hodnota nebola kódovaná viackrát.

TODO čo ak +1 aťd...

\section{Tvorba programu v ARTMC}
Tvorba programu pre nástroj ARTMC je zložitá, ľahko sa v nom tvoria chyby a je zložité
upravovať napísaný program.
Ako príklad uveďme jedoduchý program, ktorý by v jazyku C mohol vyzerať nasledovne:\\
\noindent
\texttt{
\\
while(x->next != NULL)\\
\tab x = x->next;
\\
}
\\
\noindent
Takýto program by sa do nástroja artmc prepísal ako:\\
\texttt{ 
\\
\tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab (``ifx==null'',``00000001'',2,4,2),\\
\tab (``x=y.next'',``00000010'',1,1,0,3),\\
\tab (``goto'',``00000011'',0),\\
}

Okrem tohoto kódu avšak je potrebné napísať celú triedu, ktorá vracia tento kód a dané prostredie.
Teda celý vstupný súbor by vyzeral nasledovne.


\texttt{
\\
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab \tab (``ifx==null'',``00000001'',2,4,2),\\
\tab \tab (``x=y.next'',``00000010'',1,1,0,3),\\
\tab \tab (``goto'',``00000011'',0),\\
\tab \tab (``exit'',``00000100'')]   \# Na konci musí byť inštrukcia exit\\
\tab node\_width=16\\
\tab pointer\_num=3\\
\tab desc\_num=3\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)\\
}

Ako je na prvý pohľad zrejmé, napísať program v jazyku C je výrazne jednoduchšie ako pre nástroj ARTMC. Rovanko je v C značne menšia šanca zavedenia chyby. Pri tvorbe v ARTMC je potrebné počítať premenné a správne ich značiť, počítať riadky pre pokračovanie inštrukcií atď.. Ešte zložitejšia je úprava kódu, kde len pridaním jednej drobnej zmeny je častokrát potrebné prepísať takmer celý program. Predstavme si že sa rozhodneme mierne zmeniť predchádzajúci program na:\\
\noindent
\texttt{
\\
while(x->next != NULL)\{\\
\tab x->next = malloc(sizeof(x));\\
\tab x = x->next;\\
\}
\\
}
\\
Výstup by sa výrazne zmenil. Podčiarkuté sú všetky riadky, ktoré sa zmenili alebo pribudli.


\texttt{
\\
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\underline{\tab \tab (``ifx==null'',``00000001'',2,5,2),}\\
\underline{\tab \tab (``x.next=new'',``00000010'',1,0,3,3,1),}\\
\underline{\tab \tab (``x=y.next'',``00000011'',1,1,0,4),}\\
\underline{\tab \tab (``goto'',``00000100'',0),}\\
\underline{\tab \tab (``exit'',``00000101'')]}\\
\underline{\tab node\_width=17}\\
\tab pointer\_num=3\\
\underline{\tab desc\_num=4}\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)\\
}




\chapter{Prekladače}
Prekladač je nástroj, ktorý číta zdrojový program a prekladá ho na cieľový program.
Zdrojový a cieľový program sú si vzájomne funkčne ekvivalentné. [slidy IFJ Uvod do kompilatorov]
Prekladač pozastáva z viacerých častí. Schéma bežného prekladača je na obrázku 1.
TODO [OBRAZOK 4/17 IFJ Uvod do kompilatorov].

\section{Lexikálny analyzátor}
Lexikálny analyzátor, scanner, má na vstupe zdrojový program. Tento program
rozdeľuje na lexémy - logicky oddelené lexikálne jednotky. Na výstupe je reťazec
tokenov, pričom token reprezentuje lexémy a môže obsahovať ďalšie atribúty.
Pre lepšie porozumenie viď obrázok OBR1
TODO [Obrazok IFJ 7/17 Uvod do kompilatorov - jednoducheis nieco ako int x = 0;]

\section{Syntaktický analyzátor}
Syntaktický analyzátor, parser, má na vstupe reťazec tokenov, ktoré získal
z lexikalného analyzátora(ref na kapitolu vyssie). Úlohou je skontrolovať, či
reťazec tokenov reprezentuje syntakticky správne napísaný program. Táto kontrola
prebieha za pomoci konštrukcie derivačného stromu. Ak je možné zostrojiť derivačný strom
jedná sa o program validný. Konštrukcia môže prebiehať dvôma spôsobmi a to zhora
nadol a zdola nahor.

\subsection{Analýza zhora-nadol}
TODO
\subsection{Analýza zdola-nahor}
TODO

\section{Sémantický analyzátor}
Na vstupe sémantického analyzátoru je derivačný strom, ktorý bol získaný od
syntaktického analyzátora. Sémantikcý analyzátor kontroluje sémantické aspekty
vstupného programu a to hlavne 
\begin{itemize}
    \item kontrola typov
    \item kontrola deklarácií premmených
\end{itemize}
Na výstupe je abstraktný syntaktický strom.

\section{Generátor vnútorného kódu}
Generátor vnútroneho kódu, ako názov napovedá, vytvára vnútornú reprezentáciu porgramu
z abstraktného sysntaktickeho stromu. Medzi hlavné dôvody, prečo je vhodné
vytvárať vnútroný kód patrí hlavne:
\begin{itemize}
    \item Priame vytváranie výstupného programu je nepriehladné
    \item Jednotnosť - všetky inštrukcie sa tvária rovnako
    \item Jednoduchá optimalizácia
\end{itemize}

\section{Optimalizátor}
Cieľom tejto časti je upraviť vnútrorný kód to takej podoby, aby bol efektívnejší.
Medzi optimalizácie môžu patriť:
\begin{itemize}
    \item Eliminácia mŕtveho kódu
    \item Šírenie kopírovaným
    \item Šírenie konštanty
\end{itemize}

\section{Generovanie cieľového kódu}
Optimalizovaný kód zśiakný z optimalizátora je prevedený na cieLový program.

Syntaxou riadený preklad je ...TODO

\chapter{Súčasný stav prekladača pre ARTMC}
Pre ARTMC bol vytvorený prekladač z jazyka C s názvom AVERILES. Jedná sa o
rekladač napísaný v jazyku Java. Snahou tejto práce nie je tento prekladač
upraviť ale napísať úplne nový. Hlavné dôvody prečo je potrebé vytvoriť nový
prekladač sú:
\begin{itemize}
    \item Chyby v prekladači\\
        Prekladač nedokázal spracovať určité výrazy. Niektoré výrazy prekladal nesprávne.
        Preto bolo potrebné pri zložitejších programoch manuálne kontrolovať výsledný
        program a editovať vstupný rpogram do takej formy, aby ho prekladač dokázal
        preložiť.
    \item Tažko rozšíriteľný\\
        Prekladač bol napísaný v jazyku Java dos+t zložitým a nečitateľným spôsobom. Takýto
        kód sa veľmi tažko modifikuje a rozširuje o daľsie vlastnosti. Prekladač,
        ktorý je výstupom tejto práce si dáva za cieľ čitateľný kód, do ktorého
        sa jednoducho dopĺňajú dalšie funkcionality.
    \item Nepraktické používanie\\
        Proces prekladu za pomoci Averlis pozostáva z dvoch krokov
        \begin{enumerate}
            \item Tvorba XML zo zdrojového kódu v C
            \item Preklad XML do ARTMC
        \end{enumerate}
        Takýto postup je zložitejší, nakoľko je potrebné volať dva programy.
        Zároveň programy nemajú prepínače na modifikáciu ich správania. Teda
        ich použitie je možné len v jednom užívateľskom prípade
\end{itemize}


\chapter{Implementácia}
Táto kapitola sa venuje návrhu a implementácii samotného prekladača.
Ako implementačný jazyk bol zvolený python. Kritériá, ktoré by mala výsledná
aplikácia spĺnať sa dajú rozdeliť do dvoch kategórií:
\begin{enumerate}
    \item Použiteľnosť a prenositeľnosť
    \item Moderný vývoj
\end{enumerate}

\section{Použiteľnosť a prenositeľnosť}
Výsledná aplikácia by mala byť jednoducho použiteľná. Tak ako bolo spomenuté v
kapitole XX, momentálne existujúci prekladač ma nie jednoduché použivanie. Zároveň
neumožnuje špecifikovať dalšie voľby, ktoré by uivateľ mohol potrebovať. Voľby,
ktoré by uivateľ mohol potrebovať mimo iné patria hlavne:
\begin{itemize}
    \item Možnosť špecifikovať výstupný súbor\\
        Defaultne výstupný súbor sa uloží na rovnake miesto ako vstupný a je
        pomenovaný \texttt{program.py}. Avšak užívateľ si môže zvoliť ľubovoľné umiestenie
        a názov súboru.
    \item Možnosť špecifikovať vstupný descriptor\\
        Viď kapitola X. Nakoľko sa vstupný descriptor získava z \texttt{getsth} a je
        možné, že tento program nie je dostupný, aby sa dal preklad spustiť, môže
        užívateľ túto hodnotu poskytnúť.
    \item Možnosť ignorácie dát\\
        Nakoľko podpora práce s dátami v ARTMC je výrazne obmedzená, môže byť
        vhodné nechať prekladač aby prácu s dátami neprekladal.
\end{itemize}

Rovnako medzi hlavné požiadavky patrí aj prenositeľnosť. V rámci prenositeľnosti
musíme uvažovať dva druhy:
\begin{itemize}
    \item Operačný systém\\
        Program by mal byť spustieteľný a správne bežať aspoň na Linux-och a Windows-och.
    \item Verzia pythonu\\
        Program by mal byť spustieteľný a správne bežať na všetkých hlavných verziách Pythonu.
        Viac o Pythone a verziách je v kapitole XX.
\end{itemize}

\subsection{Python}
Python je vysokoúrovňový skriptovací programovací jazyk. Podporuje viacero programovacích
paradigmat. Pre túto prácu bude použité objektovo orientované. Zároveň Python podporuje
dynamickú typovú kontrolu. MORE
Python má dve hlavné verzie. Python 2.X a Python 3.X. Dalej tieto verzie sa delia na podverzie.
Verzie a podverzie nemusia (a ani nie sú) medzi sebou kompatibilné. To prináša problém
pre programátorov, ktorý chcú písať program tak, aby fungoval pre rôzne verzie.
C2ARTMC by mal fungovať aspon pre verzie \texttt{2.6, 2.7, 3.3, 3.4, 3.5}.

\section{Moderný vývoj}
Táto časť sa venuje postupom a metódam, ktoré pri vývoji budú použité. Jedná sa
o prevažne o technológie, ktoré určujú kvalitný projekt v dnešnej dobe.

\subsection{Git}
Verzovací systém git umožnuje sledovať vývoj projektu a v jednotlivých zmenách
v histórií sa posúvať. Teda v prípade chyby je jednoduché zistiť kedy a ako chyba
vznikla. Zároveň je jednoduché sa vrátiť do stavu pred chybou.
Git umožnuje rovnako jedoduchú spoluprácu viacerých autorov. Táto práca je
prirodzene dielom jedného autora, avšak je možné, že po dokončení práce sa nájde
chyba, alebo bude treba doplniť funkcionalitu a to umožní aby iný autor túto zmenu
vykonal.
Táto práca vyuiva GitHub a je dostupná na URL.

\subsection{Unittest}
Pri pridávaní novej funkcionality sa môže stať, že sa zavedie chyba vrámci inej
funckionality. Preto je najvhodnejšie, po každej zmene otestovať všetky predtým
naprogramované funkcionality. To je prirodzene takmer nemožné. Preto sa píšu testy,
ktoré sa dajú spúsťat hromadne a je ľahko a rýchlo možné overit, že neprišlo k
zavedeniu chyby.

\subsection{Tox}
Aby bolo možné spúsťat unittesty pod rôznymi verizami pythonu a overiť, že všetky testy
upsejú na všetkých podporvovanćyh verziach pythonu v práci bude použitý nájstroj tox.
Jedná sa o porgram, ktorý potrebuje iba jeden jednoduchý konfiguračný súbor, ktorý
obsahuj spôsob ako sa spúštajú unittesty a verzie pythonov, pod ktorými chceme
aby program fungoval. Následne zavolaním programu tox bez argumentov sa testy
spustia pod všetk=ymi poždaovaními verziami a prehľadny výpis oznámi, či všetky
testy boli úspešné, prípadne ktorý test neuspel v ktorej verzii.

\chapter{Výsledná aplikácia}
TODO

\section{Testy}
TODO

\section{Nedostatky}
TODO

\section{Navrhovaná práca}

TODO
\chapter{Záver}
TODO
%=========================================================================
