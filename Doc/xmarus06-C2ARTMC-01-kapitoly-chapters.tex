%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Úvod}
Verifikácia programov, teda overovanie že program spĺňa určité požiadavky, je v dnešnej dobe veľmi žiadaná. Napriek záujmu zo strán tvorcov softvéru neexistuje skutočne univerzálne a dokonalé riešenie. Avšak mnoho subjektov vytvára verfikátory, ktoré dokážu kontrolovať určité požadované vlastnosti programov.

Jedným z aktívnych subjektov pre verifikáciu a automatizovanú analýzu je aj výskumná skupina VeriFit na Vysokom Učení Technickom v Brne. Skupina se zabývá základným výzkumom, ale taktiež aj vývojom prototypových verifikačných nástrojov. Jedným z takýchto nástrojov je aj ARTMC.

Cieľom tejto práce je implementovať prekladač, ktorý dokáže z validného programu napísanom v jazyku C vytvoriť validný funkčne rovnaký program pre nástroj ARTMC. Takýto prekladač je potrebný z dôvodu zložitého zápisu programov v jazyku pre nástroj ARTMC. ARTMC bol hlavne vyvýjaný na ukázanie možností verifikácie programov, ktoré pracujú s dynamicky viazanými dátovými štruktúrami. Počas vývoja sa nekládol dôraz na použiteľnosť ale skôr na funkčnosť, čo ma za následok pre ľudí veľmi obtiažne tvoriteľný vstupný formát.

Prekladač by mal byť dostatočne robustný aj napriek veľmi malej podmnožine jazyka C ktorú je nástroj ARTMC schopný spracovať. V prípade konštrukcie, ktorá nie je podprovaná zo strany ARTMC sa zachovať adekvátne, či to už znamená skončnie chybou a oznámením čo konkrétne nie je možné spracovať, alebo dané príkazy preskočiť. Ďalej sa očakáva čitateľnosť a udržovateľnosť napísaného prekladača pre dalšie vylepšovanie a dopĺňanie funkcionality. V neposlednom rade je dôležitá prenositeľnosť.


\chapter{Nástroj ARTMC}
ARTMC je nástroj na formálnu verifikáciu programov, ktoré manipulujú s
dynamicky viazanými dátovými štruktúrami. Tento nástroj bol vyvinutý na Fakulte
Informatiky Vysokého Učení Technického v Brne vrámci výskumnej skupiny VeriFit,
ktorá sa zaoberá verifikáciou programov. V tejto kapitole je tento nástroj
popísaný z dvoch hľadísk. Najskôr je stručný prehľad funkcionality jazyka a
následne je popísaná štruktúra vstupného súboru, ktorý je pre túto prácu
najdôležitejší.

\section{Funkcionalita a použitie ARTMC}
Majme na vstupe nerekurzívny program, ktorý manipuluje s dynamicky viazanými
šturktúrami s viacnásobnými next ukazateľmi. Snahou nástroja je overiť, že
nemôžu nastať nedovolené operácie (napr. zápis do null ukazateľa, použitie
nedefinovaného alebo už zmazaného prvku atď.)\cite{artmc1}.

Verifikačná metóda, ktorá je použitá v tomto nástroji je založená na abstraktom
regulárnom stromovom model checkingu \cite{artmc2}.

Schéma fungovania nástroja ARTMC je znázornená na obrázku \ref{fig:ARTMC_schema}.


\begin{figure}
\begin{tikzpicture}[align=center, node distance = 1cm and 0.5cm, auto]
    % Place nodes
    \node [wblock, text width=6em] (program) {program.py};
    \node [wblock, below=of program, text width=6em] (typedef) {typedef};
    
    \node [wblock, right=of program, fill=black!30!green] (generator) {run\_generator.t.sh};
    \node [wblock, right=of typedef, fill=black!30!green] (parse) {parse\_typedef.t.sh};
        
    \node [ttblock, right=of generator] (f3) {$f_n.gta$};
    \node [ttblock, above=of f3] (f2) {$f_2.gta$};
    \node [ttblock, above=of f2, yshift=-0.5cm] (f1) {$f_1.gta$};
    
    \node [ttblock, right=of parse] (x3) {$init.gta$};
    \node [ttblock, below=of x3, yshift=0.5cm] (x2) {$descr_1.gta$};
    \node [ttblock, below=of x2] (x1) {$descr_n.gta$};

    \node [wblock, right=of x3, yshift=0.75cm, fill=black!30!green] (run) {main2\_\textit{method}};

    \path [line] (program) -- (parse);
    \path [line] (program) -- (generator);
    \path [line] (typedef) -- (parse);
    \path (f2) -- node[auto=false]{\vdots} (f3);
    \path (x1) -- node[auto=false]{\vdots} (x2);
    
    \path [line] (generator) -- (f1);
    \path [line] (generator) -- (f2);
    \path [line] (generator) -- (f3);
    
    \path [line] (parse) -- (x1);
    \path [line] (parse) -- (x2);
    \path [line] (parse) -- (x3);
    
    \path [line] (x1) -- (run);
    \path [line] (x2) -- (run);
    \path [line] (x2) -- (run);
    \path [line] (f1) -- (run);
    \path [line] (f2) -- (run);
    \path [line] (f3) -- (run);
        
    \node [final, right=of run, fill=black!30!green] (anal) {analýza};
    
    \path [line] (run) -- (anal);

\end{tikzpicture}
\caption{Schéma práce nástroja ARTMC}
\label{fig:ARTMC_schema}

\end{figure}


\section{Formát vstupného súboru}
Nástroj ARTMC potrebuje pre svoju analýzu dva súbory. Jedná sa o súbor \texttt{typedefs}, ktorý obsahuje definíciu množiny počiatočnej konfigurácie a súbor \texttt{program.py} obsahujúci definíciu programu vo formáte vytvorenom pre potreby tohto nástroja.

\subsection{typedefs}
Tento súbor sa používa na špecifikáciu množiny počiatočnej konfigurácie. Súbor obsahuje množinu typov. Následne sa pamäť zostavuje z uzlov špecifikovaných typov, ktore sú prepojené za pomoci selektorov.

Existujú dva druhy selektorov:
\begin{itemize}
\item \textit{Priame spojenia}
\item \textit{Nepriame spojenia} sú popísané za pomoci cesty cez priame spojenia. Za pomoci symbola ``-'' pred priamym spojením sa značí nasledovanie spojenia späť.
\end{itemize}

Súbor typedefs pre obojsmerne viazaný list by mohol vyzerať nasledovne: \textit{(+ znamená \uv{alebo})}

\texttt{
typedef struct Tinit\\                                                            
/*? x ?*/\\                                                                       
\{\\
  struct T2 * next ;\\                                                           
  struct T2 * back ; /*? null ?*/\\                                               
\};
                                                                                \\
typedef struct T2                                                           
\{\\
  struct T2 * next ; /*? null ?*/\\                                               
  struct Any * back ; /*? -next ?*/\\
\}
+
\{\\
  struct T2 * next ;\\                                                           
  struct Any * back ; /*? -next ?*/\\                                             
\};
}

\subsection{program.py}
Zdrojový súbor obsahujúci jednu funkciu v jazyku Python, ktorá vracia dvojicu \texttt{(program, env)}.
Prvý prvok \textit{program} je zoznam n-tíc, kde každá ntica je jeden príkaz jazyka ARTMC. V tabuľke \ref{table:prikazy} sú popísané jednotlivé podporované konštrukcie.
\begin{table}[]
\begin{tabular}{ll}
x:=null             & (``x=null'',``line\_num'',x,next\_line)\\
x:=y                & (``x=y'',``line\_num'',x,y,next\_line)\\
x:=y.next           & (``x=y.next'',``line\_num'',x,y,next,next\_line)\\
x.next=y            & (``x.next=y'',``line\_num'',x,y,next,next\_line,descr\_num)\\
if x==NULL          & (``ifx==null'',``line\_num'',x,next\_line\_then,next\_line\_else)\\
if x==y             & (``ifx==y'',``line\_num'',x,y,next\_line\_then,next\_line\_else)\\
if *                & (``if*'',``line\_num'',next\_line\_then,next\_line\_else)\\
goto                & (``goto'',``line\_num'',next\_line)\\
exit                & (``exit'',``line\_num'')\\
x.next=null         & (``x.next=null'',``line\_num'',x,next,next\_line)\\
x.next=new           & (``x.next=new'',``line\_num'',x,next,next\_line, descr\_num, gen\_descr)\\
setdata             & (``setdata'',``line\_num",x,``data'',next\_line)\\
if x.data==``\dots'' & (``ifdata'',``line\_num'',x,``data'',next\_line\_then,next\_line\_else)\\
x:=random\_position & (``x=random'',``line\_num'',x,next\_line)\\
new                 & (``new'',``line\_num'',x,next\_line)\\
\end{tabular}[]
\caption{Podporované príkazy v ARTMC}
\label{table:prikazy}
\end{table}
\subsection{Popis príkazov jazyka pre ARTMC}
\begin{itemize}
    \item \textit{Identifikátor} - Prvá položka je vždy reťazec obsahujúci identifikátor inštrukcie.
    \item \textit{Číslo príkazu} - Druhá položka značená ako \textit{line\_num} identifikuje príkaz
        vrámci celého programu. Jedná sa o reťazec skladajúci sa z postupnosti
        núl a jedničiek, ktorý musí byť vrámci celého  programu jedinečný.
        Ideálny postup je číslovať inštukcie od 0 až po N a previesť tieto
        čísla do binárnej podoby. Zároveň je dôležité, aby všetky výsledné binárne čísla mali rovnako znakov.
    \item \textit{Premenné} - Označené ako \textit{x} a \textit{b}. V programe sú značené prirodzenými číslami.
    \item \textit{Ukazateľové premenné} - Označené ako \textit{next}. V programe sú číslované od 0.
    \item \textit{Ukazateľ na dalšiu inštrukciu} - Označené ako \textit{next\_line}. Označuje
        číslo riadku inštrukcie, na ktorej sa po skončení bude pokračovať. Inštrukcie
        sú číslované od nuly. Ak je použítá prípona \textit{\_then} alebo \textit{\_else}
        jedná sa o miesto pokračovania v prípade splnenia alebo nesplnenia podmienky danej inštrukcie.
    \item \textit{Deskriptory 1} - Označené ako \textit{descr\_num}. Jedinečný deskriptor použitý pri vykonávani danej inštrukcie. Deskriptory sú číslované od 1. Viac o nastavovaní hodnôt tohto deskriptoru je v podsekcii \ref{kap_descr}.
    \item \textit{Desktirpty 2} - Označené ako \textit{gen\_num}. Využíva sa iba pri príkaze \texttt{x.next=new} a označuje automatickú generáciu počiatočného deskriptoru. Nadobúda hodnoty 0 (vypnuté) a 1 (zapnuté).
\end{itemize}

\subsection{env}
Jedná sa o 6ticu \texttt{node\_width, pointer\_num, desc\_num, next\_num, err\_line, restrict\_var} obsahujúcu informácie o programe.
Význam jednotlivých položiek je nasledovný:

\begin{itemize}
\item \texttt{node\_width = pointer\_num + descr\_num + 2 + } šírka dát  
\item \texttt{pointer\_num} = Počet ukazateľových premenných zvýšený o 1
\item \texttt{desc\_num} = Počet ukazateľových deskriptorov zvýšený o 1. Viac v podsekcii\ref{kap_descr}.
\item \texttt{next\_num} = Počet next pointerov použitých v programe
\item \texttt{err\_line} = Označenie riadku, na ktorý sa skáče v prípade chyby.
\item \texttt{restrict\_var} = Automatické generovanie automatu, ktorý garantuje iba jeden výskyt programovej premennej v konfigurácii. Nadobúda hodnoty 0 (vypnuté) a 1 (zapnuté).
\end{itemize}


\subsection{Nastavovanie deskriptoru}
\label{kap_descr}
Deskriptor pozostáva z dvoch častí:
\begin{enumerate}
\item Deskriptory v konfigurácii - Jedná sa o deskriptory, ktoré sú použité v súbore \textit{typedefs}. Tieto deskriptory už nemôžu byť znova použité. Číslo najvyššieho použitého deskriptoru je možné získať zo skriptu \texttt{get\_typedef\_descr.t.sh}, ktorý je šírení v distribúcii ARTMC.
\item Vlastné deskriptory - Každý príkaz typu \texttt{x.next=y} alebo \texttt{x.next=new} dostane vlastný deskriptor, ktorý ešte nebol použitý. Nemôže byť použitý ani v konfigurácii.
\end{enumerate}

\subsection{Podpora práce s dátami v ARTMC}
Jazyk pre nástroj ARTMC obsahuje iba dve inštrukcie pre prácu s dátami. Jedná sa o príkazy \texttt{setdata} a \texttt{ifdata}. Existujú teda iba funkcie na priradenie hodnoty a na porovanie hodnoty. Ako si je možné v tabuľke \ref{table:prikazy} všímnúť, tieto funkcie berú iba jednú premennú \texttt{x}. Je to preto, lebo sa predpokladá, že štruktúra, ktorej je premenná \texttt{x} má práve jednu dátovú položku. V jazyku C môžu tieto dáta byť ľubovoľného typu, avšak pre ARTMC musia byť kódované ako postupnosť núl a jedničiek. Na skutočnej reprezentácii v binárnej podobe nezáleží, tak je napríklad vhodné prvým dátam dať napr. 	``00000001'' ďalším ``00000010'' atď. Je len potrebné aby rovnaká hodnota nebola kódovaná viackrát pod rôznymi kódmi.

Problematické je avšak spracovanie zložitejších výrazov nakoľko neexistujú funkcie na sčítanie, odčítanie a pod.. Teda napríklad výraz\\
\tab \texttt{if (x->data - 1 > y->data)}\\
sa nedá zapísať do nástroja ARTMC. Je možná určitá analýza a za pomoci sledovania šírenia konštánt alebo úpravy výrazov je možné niektoré konštrukcie preložiť. Napríklad kód:\\
\texttt{
if (x->data -1 == 0)\\
\tab \dots
}  

\noindent
po úprave výrazu je možné prepísať ako:\\
\texttt{
if (x->data == 1)\\
\tab \dots
}  

\noindent
a napríklad kód:\\
\texttt{
y->data = 0\\
\dots \textit{ak sa nezmení y a ani y->data}\\
if (x->data == y->data)\\
\tab \dots
}  

\noindent
po sledovaní šírenia konštánt je možné zaísať ako:\\
\texttt{
y->data = 0\\
\dots\\
if (x->data == 0)\\ 
\tab \dots
}  

Avšak takéto úpravy nie sú vždy možné, hlavne ak sa upravujú hodnoty vo while cykloch. Potom ostáva už len \textit{ignorácia práce s dátami}. Pri takomto postupe sa neuvažujú žiadne inštrukcie kde sa nastavuje hodnota dát a všetky podmienky, ktoré porovnávajú dáta sú nahradené inštrukciou \texttt{if*}.

\section{Tvorba programu v ARTMC}
Tvorba programu pre nástroj ARTMC je zložitá, ľahko sa v nom tvoria chyby a je zložité
upravovať napísaný program.
Ako príklad uveďme jedoduchý program, ktorý by v jazyku C mohol vyzerať nasledovne:\\
\noindent
\texttt{
\\
while(x->next != NULL)\\
\tab x = x->next;
\\
}
\noindent
Takýto program by sa do nástroja artmc prepísal ako:\\
\texttt{ 
\\
\tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab (``ifx==null'',``00000001'',2,4,2),\\
\tab (``x=y.next'',``00000010'',1,1,0,3),\\
\tab (``goto'',``00000011'',0),\\
}

Okrem tohoto kódu avšak je potrebné napísať celú triedu, ktorá vracia tento kód a dané prostredie.
Teda celý vstupný súbor by vyzeral nasledovne.


\texttt{
\\
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab \tab (``ifx==null'',``00000001'',2,4,2),\\
\tab \tab (``x=y.next'',``00000010'',1,1,0,3),\\
\tab \tab (``goto'',``00000011'',0),\\
\tab \tab (``exit'',``00000100'')]   \# Na konci musí byť inštrukcia exit\\
\tab node\_width=16\\
\tab pointer\_num=3\\
\tab desc\_num=3\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)
}

Ako je na prvý pohľad zrejmé, napísať program v jazyku C je výrazne jednoduchšie ako pre nástroj ARTMC. Rovanko je v C značne menšia šanca zavedenia chyby. Pri tvorbe v ARTMC je potrebné počítať premenné a správne ich značiť, počítať riadky pre pokračovanie inštrukcií atď.. Ešte zložitejšia je úprava kódu, kde len pridaním jednej drobnej zmeny je častokrát potrebné prepísať takmer celý program. Predstavme si že sa rozhodneme mierne zmeniť predchádzajúci program na:\\
\noindent
\texttt{
\\
while(x->next != NULL)\{\\
\tab x->next = malloc(sizeof(x));\\
\tab x = x->next;\\
\}
\\
}

Výstup by sa výrazne zmenil. Podčiarkuté sú všetky riadky, ktoré sa zmenili alebo pribudli.


\texttt{
\\
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\underline{\tab \tab (``ifx==null'',``00000001'',2,5,2),}\\
\underline{\tab \tab (``x.next=new'',``00000010'',1,0,3,3,1),}\\
\underline{\tab \tab (``x=y.next'',``00000011'',1,1,0,4),}\\
\underline{\tab \tab (``goto'',``00000100'',0),}\\
\underline{\tab \tab (``exit'',``00000101'')]}\\
\underline{\tab node\_width=17}\\
\tab pointer\_num=3\\
\underline{\tab desc\_num=4}\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)
}

\chapter{Prekladače}
\label{kap_prekladace}
Prekladač je nástroj, ktorý číta zdrojový program a prekladá ho na cieľový program.
Zdrojový a cieľový program sú si vzájomne funkčne ekvivalentné\cite{meduna}.
Prekladač pozastáva z viacerých častí. Schéma bežného prekladača je na obrázku \ref{fig:sch}.

\begin{figure}[h]
\begin{tikzpicture}[align=center, node distance = 2cm and 3cm, auto]
    % Place nodes
    \node [block] (lex) {Lexikálny analýzátor};
    \node [cloud, left of=lex, align=center] (zdroj) {Zdrojový\\program};
    \node [block, right=of lex] (synta) {Syntaktický analyzátor};
    \node [block, below=of synta] (sema) {Sémantický analýzátor};
    \node [block, below=of lex, align=center] (gen) {Generátor vnú\-tor\-né\-ho kódu};
    \node [block, below=of gen] (opti) {Op\-ti\-ma\-li\-zá\-tor};
    \node [block, below=of sema, align=center] (gen_ciel) {Generátor cie\-ľo-vé\-ho kódu};
    \node [cloud, right of=gen_ciel, align=center] (ciel) {Cieľový\\program};
    % Draw edges
    \path [line,dashed] (zdroj) -- (lex);
    
    \draw[->] (lex.10) -- node[]{Tokeny} (synta.170);
    \draw[->,dashed] (synta.190) -- (lex.-10);

    \draw[->] (synta.260) -- node[xshift=0.5cm]{Derivačný strom} (sema.100);
    \draw[->,dashed] (sema.80) -- (synta.280);

    \draw[->] (sema.170) -- node[yshift=-0.5cm,align=center]{Abstraktný\\syntaktický strom} (gen.10);
    \draw[->,dashed] (gen.-10) -- (sema.190);


    \path [line] (gen) -- node[xshift=-3cm]{Vnútorný kód} (opti);

    \path [line] (opti) -- node[align=center]{Optimalizovaný\\vnútorný kód} (gen_ciel);

    \path [line,dashed] (gen_ciel) -- (ciel);
    

\end{tikzpicture}
\caption{Schéma prekladača TODO ref slidy IFJ}
\label{fig:sch}

\end{figure}

\section{Lexikálny analyzátor}
\label{sec_lex}
Lexikálny analyzátor, scanner, má na vstupe zdrojový program. Tento program
rozdeľuje na lexémy - logicky oddelené lexikálne jednotky. Na výstupe je reťazec
tokenov, pričom token reprezentuje lexémy a môže obsahovať ďalšie atribúty.
Pre lepšie porozumenie viď obrázok \ref{fig:lex}.

\begin{center}
\begin{figure}[h]
\begin{tikzpicture}[auto]

	\node [tblock] (s3) {y};
	\node[single arrow,draw=black,fill=black!10,minimum height=1cm, shape border rotate=-180, above=of s3] (ar1) {};	
	
    \node [wblock, above=of ar1] (first) {x = y * 2};
    \node [tblock, left=of s3] (s2) {=};
    \node [tblock, left=of s2] (s1) {x};


    \node [tblock, right=of s3] (s4) {*};
    \node [tblock, right=of s4] (s5) {2};  
	   
	   
	\node [data, below of=s1] (p1) {id \nodepart{second} x};    
	\node [data, below of=s2] (p2) {=};  
	\node [data, below of=s3] (p3) {id \nodepart{second} y};
	\node [data, below of=s4] (p4) {*}; 
	\node [data, below of=s5] (p5) {int \nodepart{second} 2};

	\node [label, left of=s1, xshift=-1cm] (t1) {Lexémy:};   
    \node [label, left of=p1, xshift=-1cm] (t2) {Tokeny:};  


\end{tikzpicture}
\caption{Schéma rozdelovania na lexémy a tokeny}
\label{fig:lex}

\end{figure}
\end{center}


\section{Syntaktický analyzátor}
Syntaktický analyzátor, parser, má na vstupe reťazec tokenov, ktoré získal
z lexikalného analyzátora. Úlohou je skontrolovať, či
reťazec tokenov reprezentuje syntakticky správne napísaný program. Táto kontrola
prebieha za pomoci konštrukcie derivačného stromu. Ak je možné zostrojiť derivačný strom
jedná sa o program validný. Konštrukcia môže prebiehať dvôma spôsobmi a to zhora
nadol a zdola nahor. \cite{meduna} 

\subsection{Analýza zhora-nadol}
Metóda zhora-nadol sa snaží skonštruovať derivačný strom od najvyššej úrovne a postupne prechádza derivačný strom dole za využita formálnych pravidiel gramatiky. To znamená, že derivačný strom sa konštruje od koreňa smerom k listom, zľava doprava, poďla ľavej derivácie. Syntaktická analýza zhora dole využíva pre svoju prácu LL syntaktické analyzátory. \cite{aho}

\subsection{Analýza zdola-nahor}
Metóda zdola-nahor sa snaží skonštruovať derivačný strom od najnižšej úrovne a postupne prechadza derivačný strom smerom ku koreni za využitia formálnych pravidiel gramatiky. To znamená, že sa najskôr identifikujú jednotlivé symboly z ktorých sa následne vytvára derivačný strom. Táto metóda využíva precedenčnú tabuľku. \cite{aho}

\section{Sémantický analyzátor}
Na vstupe sémantického analyzátoru je derivačný strom, ktorý bol získaný od
syntaktického analyzátora. Sémantikcý analyzátor kontroluje sémantické aspekty
vstupného programu a to hlavne 
\begin{itemize}
    \item kontrola typov
    \item kontrola deklarácií premmených
\end{itemize}
Na výstupe je abstraktný syntaktický strom.

\section{Generátor vnútorného kódu}
Generátor vnútroneho kódu, ako názov napovedá, vytvára vnútornú reprezentáciu porgramu
z abstraktného sysntaktickeho stromu. Medzi hlavné dôvody, prečo je vhodné
vytvárať vnútroný kód patrí hlavne:
\begin{itemize}
    \item Priame vytváranie výstupného programu je nepriehladné
    \item Jednotnosť - všetky inštrukcie sa tvária rovnako
    \item Jednoduchá optimalizácia
\end{itemize}

\section{Optimalizátor}
Cieľom tejto časti je upraviť vnútrorný kód to takej podoby, aby bol efektívnejší.
Medzi optimalizácie môžu patriť:
\begin{itemize}
    \item Eliminácia mŕtveho kódu
    \item Šírenie kopírovaným
    \item Šírenie konštanty
\end{itemize}

\section{Generovanie cieľového kódu}
Optimalizovaný kód získaný z optimalizátora je prevedený na cieľový program.

\section{Syntaxou riadený preklad}
\label{sec_synta}
Jedná sa o prístup, keď celý prekladač je riadený procesom parsovania. Teda ku každému pravidlu gramatiky sú priradené dalšie akcie, ktoré pokrývajú ostatné fázy prekladu. Medzi akcie môže napríklad patriť:
\begin{itemize}
    \item Vyvolanie sémantickej kontroly
    \item Ukladanie informácií napr. do tabuľky symbolov alebo tabuľky návestí
    \item Generovanie kódu
\end{itemize}
Prevažne pri využití tejto techniky postačuje jeden priechod cez zdrojový program.


\chapter{Súčasný stav prekladača pre ARTMC}
Pre ARTMC bol vytvorený prekladač z jazyka C s názvom AVERILES. Jedná sa o
rekladač napísaný v jazyku Java. Snahou tejto práce nie je tento prekladač
upraviť ale napísať úplne nový. Hlavné dôvody prečo je potrebé vytvoriť nový
prekladač sú:
\begin{itemize}
    \item Chyby v prekladači\\
        Prekladač nedokázal spracovať určité výrazy. Niektoré výrazy prekladal nesprávne.
        Preto bolo potrebné pri zložitejších programoch manuálne kontrolovať výsledný
        program a editovať vstupný rpogram do takej formy, aby ho prekladač dokázal
        preložiť.
    \item Tažko rozšíriteľný\\
        Prekladač bol napísaný v jazyku Java dos+t zložitým a nečitateľným spôsobom. Takýto
        kód sa veľmi tažko modifikuje a rozširuje o daľsie vlastnosti. Prekladač,
        ktorý je výstupom tejto práce si dáva za cieľ čitateľný kód, do ktorého
        sa jednoducho dopĺňajú dalšie funkcionality.
    \item Nepraktické používanie\\
        Proces prekladu za pomoci Averlis pozostáva z dvoch krokov
        \begin{enumerate}
            \item Tvorba XML zo zdrojového kódu v C
            \item Preklad XML do ARTMC
        \end{enumerate}
        Takýto postup je zložitejší, nakoľko je potrebné volať dva programy.
        Zároveň programy nemajú prepínače na modifikáciu ich správania. Teda
        ich použitie je možné len v jednom užívateľskom prípade
\end{itemize}

\chapter{Implementácia}
Táto kapitola sa venuje návrhu a implementácii samotného prekladača.
Ako implementačný jazyk bol zvolený Python. Kritériá, ktoré by mala výsledná
aplikácia spĺnať sa dajú rozdeliť do dvoch kategórií:
\begin{enumerate}
    \item Použiteľnosť a prenositeľnosť
    \item Moderný vývoj
\end{enumerate}

\section{Použiteľnosť a prenositeľnosť}
Výsledná aplikácia by mala byť jednoducho použiteľná. Tak ako bolo spomenuté v
kapitole XX, momentálne existujúci prekladač ma nie jednoduché použivanie. Zároveň
neumožnuje špecifikovať dalšie voľby, ktoré by uivateľ mohol potrebovať. Voľby,
ktoré by uivateľ mohol potrebovať mimo iné patria hlavne:
\begin{itemize}
    \item Možnosť špecifikovať výstupný súbor\\
        Defaultne výstupný súbor sa uloží na rovnake miesto ako vstupný a je
        pomenovaný \texttt{program.py}. Avšak užívateľ si môže zvoliť ľubovoľné umiestenie
        a názov súboru.
    \item Možnosť špecifikovať vstupný descriptor\\
        Viď kapitola X. Nakoľko sa vstupný descriptor získava z \texttt{getsth} a je
        možné, že tento program nie je dostupný, aby sa dal preklad spustiť, môže
        užívateľ túto hodnotu poskytnúť.
    \item Možnosť ignorácie dát\\
        Nakoľko podpora práce s dátami v ARTMC je výrazne obmedzená, môže byť
        vhodné nechať prekladač aby prácu s dátami neprekladal.
\end{itemize}

Rovnako medzi hlavné požiadavky patrí aj prenositeľnosť. V rámci prenositeľnosti
musíme uvažovať dva druhy:
\begin{itemize}
    \item Operačný systém\\
        Program by mal byť spustieteľný a správne bežať aspoň na Linux-och a Windows-och.
    \item Verzia Pythonu\\
        Program by mal byť spustieteľný a správne bežať na všetkých hlavných verziách Pythonu.
        Viac o Pythone a verziách je v kapitole XX.
\end{itemize}

\subsection{Python}
Python je vysokoúrovňový skriptovací programovací jazyk. Podporuje viacero programovacích
paradigmat. Pre túto prácu bude použité objektovo orientované. Zároveň Python podporuje
dynamickú typovú kontrolu. MORE
Python má dve hlavné verzie. Python 2.X a Python 3.X. Dalej tieto verzie sa delia na podverzie.
Verzie a podverzie nemusia (a ani nie sú) medzi sebou kompatibilné. To prináša problém
pre programátorov, ktorý chcú písať program tak, aby fungoval pre rôzne verzie.
C2ARTMC by mal fungovať aspon pre verzie \texttt{2.6, 2.7, 3.3, 3.4, 3.5}.

\section{Moderný vývoj}
Táto časť sa venuje postupom a metódam, ktoré pri vývoji budú použité. Jedná sa
o prevažne o technológie, ktoré určujú kvalitný projekt v dnešnej dobe.

\subsection{Git}
Verzovací systém git umožnuje sledovať vývoj projektu a v jednotlivých zmenách
v histórií sa posúvať. Teda v prípade chyby je jednoduché zistiť kedy a ako chyba
vznikla. Zároveň je jednoduché sa vrátiť do stavu pred chybou.
Git umožnuje rovnako jedoduchú spoluprácu viacerých autorov. Táto práca je
prirodzene dielom jedného autora, avšak je možné, že po dokončení práce sa nájde
chyba, alebo bude treba doplniť funkcionalitu a to umožní aby iný autor túto zmenu
vykonal.
Táto práca vyuiva GitHub a je dostupná na \texttt{https://github.com/marusak/C2ARTMC}.

\subsection{Unittest}
Pri pridávaní novej funkcionality sa môže stať, že sa zavedie chyba vrámci inej
funckionality. Preto je najvhodnejšie, po každej zmene otestovať všetky predtým
naprogramované funkcionality. To je prirodzene takmer nemožné. Preto sa píšu testy,
ktoré sa dajú spúsťat hromadne a je ľahko a rýchlo možné overit, že neprišlo k
zavedeniu chyby.

\subsection{Tox}
Aby bolo možné spúsťat unittesty pod rôznymi verizami pythonu a overiť, že všetky testy
upsejú na všetkých podporvovanćyh verziach pythonu v práci bude použitý nájstroj tox.
Jedná sa o porgram, ktorý potrebuje iba jeden jednoduchý konfiguračný súbor, ktorý
obsahuj spôsob ako sa spúštajú unittesty a verzie pythonov, pod ktorými chceme
aby program fungoval. Následne zavolaním programu tox bez argumentov sa testy
spustia pod všetk=ymi poždaovaními verziami a prehľadny výpis oznámi, či všetky
testy boli úspešné, prípadne ktorý test neuspel v ktorej verzii.


\chapter{Výsledná aplikácia}
Aplikácia bola vytvorená s ohľadom na zadanie bakalárskej práce. Boli dodržané všetky body zadania. Pri vývoji som sa držal požadovaných vlastností na kód a vývoj spomenutých v kapitole TODO ref. Hneď po vytvorení prvej skutočne funkčnej časti kódu boli vytvárané automatické testy pre overenie skutočne fungujúcich implemenotvaných častí a overenie že počas pridávania novej funkcionality neprišlo k regresii v inej časti kódu. 

Kód bol od začiatku publikovaný na GitHub-e s ohľadom na odporúčané praktiky pri využívaný verzovacieho systému git. História je prehľadná a je možné v nej jedoducho sa vracať alebo zisťovať ktorá časť kódu bola kedy implementovaná.

Výsledný program bol poriadne otestovaný na veľkej sade testov. Všetky testy prešli úspešne na všetkých požadovaných operačných systémoch ako aj verziách Pythonu.



\section{Výsledná implementácia}
Ako prvá časť bol implementovaný lexikálny analyzátor. Jedná sa o samotnú triedu \texttt{Scanner}, ktorá v inizializácii berie názov súboru z programom v jazyku C. Následne je vstupný program načítaný a predspracovaný. Jedná sa hlavne o odstránenie komentárov a nahradenie skupín bielych znakov jednou medzerou. Tieto úpravy následne umožnujú jednoduchšie delenie kódu na tokeny. Trieda lexikálneho analyzátora poskytuje metódu \texttt{get\_token}, ktorá vráti práve jeden token. Na delenie sa nevyužívajú regulárne výrazy, ale podľa prvého neprečítaného znaku sa scanner rozhoduje o aký token sa môže jednať. Následne po rozpoznaní tokenu, je vrátený token, ktorý je reprezentovaný jedným číslom - jedná sa o imitáciu \texttt{enum} pre jazyk Python. Konkrétna hodnota tokenu sa nevracia priamo a je možné ju získať volaním funkcie \texttt{get\_value}. Scanner poskytuje aj metódu \texttt{unget\_token}, ktorá vráti jeden token späť do vstupného reťazca. Nakoľko je ale scanner ako aj celý prekladač jednopriechodový, je táto funkcia implementovaná instančnou premennou, ktorá drží vrátenú hodnotu. Výhodou je jednoduchá implementácia, nevýhodou je možné vrátiť iba jeden token.

Následne bol tvorený syntaktický analyzátor, ktorý je implementovaný ako trieda \texttt{Parser}. Jedná sa o syntaxou riadený preklad a preto je samotný analyzátor najdlhšia časť kódu. Napriek svojej veľkosti sa jedná o pomerne jednoduchý program. V princípe je celá analýza jeden while cyklus, ktorý čaká až skončí vstupný súbor a scanner vráti EOF. V tomto cykle sa prečíta prvý token a sa rozhodne o aký príkaz sa jedná. V tejto úrovni sa môže jednať iba do definícu alebo deklaráciu programu alebo premennej. Spracovanie premennej je priamočiara záležitosť. Spracovanie funkcie obsluhuje funkcia \texttt{parse\_function}, ktorá je obdobne jeden while cyklus, ktorý volá funkciu \texttt{parse\_command} až pokiaľ nenarazí na ukončujúcu zloženú zátvorku. Funkcia \texttt{parse\_command}
na základe prvého tokenu zavolá funkcie na spracovanie príkazu, napríklad \texttt{parse\_if} alebo \texttt{parse\_assignment}. Ak sa jedná o príkaz, ktorý vytvára daľšiu úroveň zanorenia ako napríklad \texttt{if} alebo \texttt{while}, celá úroveň je spracovaná touto funkciou za volania  \texttt{parse\_command} na spracovanie jednotlivých príkazov. Hovoríme teda o rekurzívnom zanorovaní.

Ako bolo spomenuté v sekcii \ref{sec_synta} ohľadom syntaxou riadenom preklade, počas syntaktickej analýzy sa vykonávajú aj dalšie akcie. Pri nájedení novej premennej je táto premenná vložená do tabuľky symbolov, ktorú vlastní trieda \texttt{Parser} a poskytuje sadu inštrukcií na prácu s ňou. Pri prečítaní celého príkazu sa vygeneruje inštrukcia vo vnútrom kóde. Na spracovanie vnúorného kódu bola vytvorená trieda \texttt{Generate}. Tento názov napovedá, že trieda nie len že príjma od parseru inštrukcie vo vnútornej reprezentácií, ale aj generuje cieľový kód. Trieda poskytuje celú radu pre vkladanie inštrukcií, ktoré začínajú prefixom \texttt{new\_i\_}. Okrem toho obsahuje funkciu \texttt{get\_full\_result}, ktorá má za úlohu vrátiť kód vo výstupnom jazyku pripravený na výpis alebo zápis do súboru. Táto funkcia volá všetky potrebné funkcie na generovanie a dokončovanie inštrukcií z vnútorného kódu do výsledného kódu.

Schéma fungovania výslednej implementácie je znázornená na obrázku... 
TODO ako vyzera schema viac ako meduna/14 skutocne nazy tried?

\section{Zaujímavé vlastnosti}

TODO fetury ake mame, skratove, ignore data...

\section{Nedostatky a známe chyby}
Vo výslednej aplikácií nie sú žiadne známe chyby a všetky požiadavky boli implementované.

\section{Navrhovaná práca}
Všetky požadované vlastnosti pre výslednú aplikáciu boli implementované. Avšak je možné, že časom si používanie ARTMC bude vyžadovať dalšie funkcie, napríklad nové konštrukcie z jazyka C a teda bude potrebné daný kód doplniť. 

\chapter{Záver}
TODO
%=========================================================================
