%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Úvod}
Verifikácia programov, teda overovanie že program spĺňa určité požiadavky, je v~dnešnej dobe veľmi žiadaná. Napriek záujmu zo strán tvorcov softvéru neexistuje skutočne univerzálne a~dokonalé riešenie. Avšak mnoho subjektov vytvára verfikátory, ktoré dokážu kontrolovať určité požadované vlastnosti programov.

Jedným z~aktívnych subjektov pre verifikáciu a~automatizovanú analýzu je aj výskumná skupina VeriFIT na Vysokom Učení Technickom v~Brne. Skupina se zaoberá základným výskumom, ale taktiež aj vývojom prototypových verifikačných nástrojov. Jedným z~takýchto nástrojov je aj ARTMC\footnote{http://www.fit.vutbr.cz/research/groups/verifit/tools/artmc/}.

Cieľom tejto práce je implementovať prekladač, ktorý dokáže z~validného programu napísanom v~jazyku C vytvoriť validný funkčne rovnaký program vo vstupnom formáte nástroja ARTMC. ARTMC bol hlavne vyvíjaný na ukázanie možností verifikácie programov, ktoré pracujú s~dynamicky viazanými dátovými štruktúrami. Počas vývoja sa nekládol dôraz na použiteľnosť ale skôr na funkčnosť. Od začiatku vývoja sa počítalo s~prekladačom, ktorý ale nikdy nevznikol. Tento fakt má za následok veľmi obtiažne manuálne tvoriteľný vstupný formát. 

Prekladač by mal byť dostatočne robustný aj napriek veľmi malej podmnožine jazyka C, ktorú je nástroj ARTMC schopný spracovať. V~prípade konštrukcie, ktorá nie je podporovaná zo strany ARTMC, by sa mal  zachovať adekvátne, či to už znamená skončenie chybou a~oznámením čo konkrétne nie je možné spracovať, alebo dané príkazy preskočiť. Ďalej sa očakáva čitateľnosť a~udržiavateľnosť napísaného prekladača pre ďalšie vylepšovanie a~dopĺňanie funkcionality. V~neposlednom rade je dôležitá aj prenositeľnosť.


\chapter{Nástroj ARTMC}
\label{kap_artmc}
ARTMC je nástroj na formálnu verifikáciu programov, ktoré manipulujú
s~dynamicky viazanými dátovými štruktúrami. Tento nástroj bol vyvinutý na Fakulte
informačných technológií Vysokého Učení Technického v~Brne vrámci výskumnej skupiny VeriFIT,
ktorá sa zaoberá verifikáciou programov. V~tejto kapitole je tento nástroj
popísaný z~dvoch hľadísk. Najskôr je stručný prehľad funkcionality jazyka
a~následne je popísaná štruktúra vstupného súboru, ktorý je pre túto prácu
najdôležitejší.

\section{Funkcionalita a~použitie ARTMC}
Majme na vstupe nerekurzívny program, ktorý manipuluje s~dynamicky viazanými
štruktúrami s~viacnásobnými next ukazateľmi. Snahou nástroja je overiť, že
nemôžu nastať nedovolené operácie (napr. zápis do null ukazateľa, použitie
nedefinovaného alebo už zmazaného prvku atď.)\cite{artmc1}.

Verifikačná metóda, ktorá je použitá v~tomto nástroji je založená na abstraktom
regulárnom stromovom model checkingu. Vrámci tejto metódy je konfigurácia pamäte programu reprezentovaná stromom nad konečnou abecedou. Nekonečná množina konfigurácií je reprezentovaná stromovými automatmi. Technika následne počíta množinu dosiahnuteľných konfigurácií reprezenotavaných opäť stromovým automatom\cite{artmc2}.

Schéma fungovania nástroja ARTMC je znázornená na obrázku \ref{fig:ARTMC_schema}.


\begin{figure}[h]
\begin{tikzpicture}[align=center, node distance = 1cm and 0.5cm, auto, >=latex']
    % Place nodes
    \node [block] (program) {program.py};
    \node [block, below=of program] (typedef) {typedefs};
    
    \node [block, right=of program, fill=black!30] (generator) {run\_generator.t.sh};
    \node [block, right=of typedef, fill=black!30] (parse) {parse\_typedef.t.sh};
        
    \node [small_w_block, right=of generator] (f3) {$f_n.gta$};
    \node [small_w_block, above=of f3] (f2) {$f_2.gta$};
    \node [small_w_block, above=of f2, yshift=-0.5cm] (f1) {$f_1.gta$};
    
    \node [small_w_block, right=of parse] (x3) {$init.gta$};
    \node [small_w_block, below=of x3, yshift=0.5cm] (x2) {$descr_1.gta$};
    \node [small_w_block, below=of x2] (x1) {$descr_n.gta$};

    \node [block, right=of x3, yshift=1.0cm, fill=black!30] (run) {main2\_\textit{method}};

	\draw [->] (program) |-++(1.5,-1.0) -| (parse);
    \path [line] (program) -- (generator);
    \path [line] (typedef) -- (parse);
    \path (f2) -- node[auto=false]{\vdots} (f3);
    \path (x1) -- node[auto=false]{\vdots} (x2);
    
    \path [line] (generator) |- (f1);
    \path [line] (generator.70) |- (f2);
    \path [line] (generator) |- (f3);
    
    \path [line] (parse) |- (x1);
    \path [line] (parse.290) |- (x2);
    \path [line] (parse) |- (x3);
    
    \path [line] (x1) -| (run.290);
    \path [line] (x2) -| (run);
    \path [line] (x3) -| (run.250);
    \path [line] (f1) -| (run.70);
    \path [line] (f2) -| (run);
    \path [line] (f3) -| (run.110);
        
    \node [cloud, right=of run, fill=black!30] (anal) {analýza};
    
    \path [line] (run) -- (anal);

\end{tikzpicture}
\caption{Schéma práce nástroja ARTMC}
\label{fig:ARTMC_schema}
\end{figure}


\section{Formát vstupného súboru}
Nástroj ARTMC potrebuje pre svoju analýzu dva súbory. Jedná sa o~súbor \texttt{typedefs}, ktorý obsahuje definíciu množiny počiatočnej konfigurácie a~súbor \texttt{program.py}, obsahujúci definíciu programu vo formáte vytvorenom pre potreby tohto nástroja.

\subsection{typedefs}
Tento súbor sa používa na špecifikáciu množiny počiatočnej konfigurácie, ktorá môže byť obecne nekonečná (napr. zoznam ľubovoľnej dĺžky). Súbor obsahuje množinu typov. Následne sa pamäť zostavuje z~uzlov špecifikovaných typov, ktoré sú prepojené za pomoci selektorov.
\newpage

Existujú dva druhy selektorov:
\begin{itemize}
\item \textit{Priame spojenia}
\item \textit{Nepriame spojenia} sú popísané za pomoci cesty cez priame spojenia. Za pomoci symbola ``-'' pred priamym spojením sa značí nasledovanie spojenia smerom späť.
\end{itemize}

Súbor \texttt{typedefs} pre obojsmerne viazané listy ľubovoľnej dĺžky, ktorých začiatok je odkazovaný premennou \uv{\texttt{x}}, by vyzeral nasledovne: \textit{(+ znamená \uv{alebo})}

\code{%
typedef struct Tinit\\                                                            
/*? x ?*/\\                                                                       
\{\\
\tab struct T2 * next ;\\                                                           
\tab struct T2 * back ; /*? null ?*/\\                                               
\};
                                                                                \\
typedef struct T2                                                           
\{\\
\tab struct T2 * next ; /*? null ?*/\\                                               
\tab struct Any * back ; /*? -next ?*/\\
\}
+
\{\\
\tab struct T2 * next ;\\                                                           
\tab struct Any * back ; /*? -next ?*/\\                                             
\};
}

\subsection{program.py}
Jedná sa o~súbor obsahujúci jednu funkciu v~jazyku Python, ktorá vracia dvojicu \texttt{(program, env)}.
Prvý prvok \texttt{program} je zoznam n-tíc, kde každá n-tica je jeden príkaz jazyka ARTMC. V~tabuľke \ref{table:prikazy} sú popísané jednotlivé podporované konštrukcie.

\begin{table}[h]
\centering
\begin{tabular}{l|l}
\multicolumn{1}{c|}{\textbf{konštrukcia}} & \multicolumn{1}{c}{\textbf{zápis pre ARTMC}} \\ \hline
x := NULL             & (``x=null'',``line\_num'',x,next\_line)\\
x := y                & (``x=y'',``line\_num'',x,y,next\_line)\\
x := y.next           & (``x=y.next'',``line\_num'',x,y,next,next\_line)\\
x.next = y            & (``x.next=y'',``line\_num'',x,y,next,next\_line,descr\_num)\\
if (x == NULL)          & (``ifx==null'',``line\_num'',x,next\_line\_then,next\_line\_else)\\
if (x == y)             & (``ifx==y'',``line\_num'',x,y,next\_line\_then,next\_line\_else)\\
if (*)                & (``if*'',``line\_num'',next\_line\_then,next\_line\_else)\\
goto                & (``goto'',``line\_num'',next\_line)\\
exit                & (``exit'',``line\_num'')\\
x.next = NULL         & (``x.next=null'',``line\_num'',x,next,next\_line)\\
x.next = new           & (``x.next=new'',``line\_num'',x,next,next\_line, descr\_num, gen\_descr)\\
setdata             & (``setdata'',``line\_num'',x,``data'',next\_line)\\
if (x.data == ``\dots'') & (``ifdata'',``line\_num'',x,``data'',next\_line\_then,next\_line\_else)\\
x := random\_pos & (``x=random'',``line\_num'',x,next\_line)\\
new                 & (``new'',``line\_num'',x,next\_line)\\
\end{tabular}
\caption{Podporované príkazy v~ARTMC}
\label{table:prikazy}
\end{table}

\subsection{Popis príkazov jazyka pre ARTMC}
\begin{itemize}
    \item \textit{Identifikátor} - Prvá položka je vždy reťazec obsahujúci identifikátor inštrukcie.
    \item \textit{Číslo príkazu} - Druhá položka označená ako \uv{\texttt{line\_num}} identifikuje príkaz
        vrámci celého programu. Jedná sa o~reťazec skladajúci sa z~postupnosti
        núl a~jedničiek, ktorý musí byť vrámci celého  programu jedinečný.
        Najvhodnejší postup je číslovať inštrukcie od 0 až po N a~previesť tieto
        čísla do binárnej podoby. Zároveň je dôležité, aby všetky výsledné binárne čísla mali rovnako znakov.
    \item \textit{Premenné} - Označené ako \uv{\texttt{x}} a~\uv{\texttt{y}}. V~programe sú reprezentované prirodzenými číslami začínajúce od 1.
    \item \textit{Ukazateľové položky} - Označené ako \uv{\texttt{next}}. V~programe sú reprezentované prirodzenými číslami začínajúce od 0.
    \item \textit{Ukazateľ na ďalšiu inštrukciu} - Označené ako \uv{\texttt{next\_line}}. Označuje
        číslo riadku inštrukcie, na ktorej sa po skončení bude pokračovať. Inštrukcie
        sú číslované od nuly. Ak je použitá prípona \uv{\texttt{\_then}} alebo \uv{\texttt{\_else}}
        jedná sa o~miesto pokračovania v~prípade splnenia alebo nesplnenia podmienky danej inštrukcie.
    \item \textit{Deskriptory 1} - Označené ako \uv{\texttt{descr\_num}}. Jedinečný deskriptor použitý pri vykonávaní danej inštrukcie. Deskriptory sú číslované od 1. Viac o~nastavovaní hodnôt tohto deskriptoru je v~podsekcii \ref{kap_descr}.
    \item \textit{Deskriptory 2} - Označené ako \uv{\texttt{gen\_descr}}. Využíva sa iba pri príkaze \texttt{x.next=new} a~označuje automatickú generáciu počiatočného deskriptoru. Nadobúda hodnoty 0 (vypnuté) a~1 (zapnuté).
\end{itemize}

\subsection{env}
Jedná sa o~6ticu (\texttt{node\_width, pointer\_num, descr\_num, next\_num, err\_line,\\ restrict\_var}) obsahujúcu informácie o~programe.
Význam jednotlivých položiek je nasledovný:

\begin{itemize}
\item \texttt{node\_width = pointer\_num + descr\_num + 2 + } šírka dát  
\item \texttt{pointer\_num} = Počet ukazateľových premenných zvýšený o~1
\item \texttt{desc\_num} = Počet ukazateľových položiek zvýšený o~1 (viď podsekciu \ref{kap_descr})
\item \texttt{next\_num} = Počet next pointerov použitých v~programe
\item \texttt{err\_line} = Označenie riadku, na ktorý sa skáče v~prípade chyby
\item \texttt{restrict\_var} = Automatické generovanie automatu, ktorý garantuje iba jeden výskyt programovej premennej v~konfigurácii. Nadobúda hodnoty 0 (vypnuté) a~1 (zapnuté).
\end{itemize}


\subsection{Nastavovanie deskriptoru}
\label{kap_descr}
Deskriptor pozostáva z~dvoch častí:
\begin{enumerate}
\item \textit{Deskriptory v~konfigurácii} - Jedná sa o~deskriptory, ktoré sú použité v~súbore \textit{typedefs}. Tieto deskriptory už nemôžu byť znova použité. Číslo najvyššieho použitého deskriptoru je možné získať zo skriptu \texttt{get\_typedef\_descr.t.sh}, ktorý je súčasťou distribúcie ARTMC.
\item \textit{Vlastné deskriptory} - Každému príkazu typu \texttt{x.next=y} alebo \texttt{x.next=new} je priradení vlastný deskriptor, ktorý ešte nebol použitý. Nemôže byť použitý ani v~konfigurácii.
\end{enumerate}

\subsection{Podpora práce s~dátami v~ARTMC}
Jazyk pre nástroj ARTMC obsahuje iba dve inštrukcie pre prácu s~dátami. Jedná sa o~príkazy \texttt{setdata} a~\texttt{ifdata}. Existujú teda iba funkcie na priradenie hodnoty a~na porovnanie hodnoty. Ako si je možné v~tabuľke \ref{table:prikazy} všimnúť, tieto funkcie berú iba jednú premennú. Je to z~dôvodu, že nástroj ARTMC predpokladá, že štruktúra ktorého typu je daná premenná obsahuje práve jednu dátovú položku. V~jazyku C môžu tieto dáta byť ľubovoľného typu, avšak pre ARTMC musia byť kódované ako postupnosť núl a~jedničiek. Na skutočnej reprezentácii v~binárnej podobe nezáleží, tak je vhodné prvým dátam dať napríklad postupnosť ``00000001'' ďalším ``00000010'' atď. Avšak je potrebné aby jedna hodnota nebola kódovaná viackrát pod rôznymi kódmi.

Problematické je avšak spracovanie zložitejších výrazov nakoľko neexistujú funkcie na sčítanie, odčítanie a~pod.. Teda napríklad výraz
\codeline{if (x->data - 1 > y->data)}
sa nedá zapísať do nástroja ARTMC. Je možná určitá analýza a~za pomoci sledovania šírenia konštánt alebo úpravy výrazov je možné niektoré konštrukcie preložiť.
\newpage
\noindent
Ako príklad uveďme výraz: \codeline{if (x->data -1 == 0)} po úprave výrazu je možné prepísať ako: \codeline{if (x->data == 1)}
A~napríklad kód:

\code{%
y->data = 0\\
\dots \textit{ak sa nezmení y a~ani y->data}\\
if (x->data == y->data)\\
\tab \dots
}

\noindent
po sledovaní šírenia konštánt je možné zapísať ako:

\code{%
y->data = 0\\
\dots\\
if (x->data == 0)\\ 
\tab \dots
}  

Avšak takéto úpravy nie sú vždy možné, hlavne ak sa menia hodnoty vo while cykloch. Potom je možná len \uv{ignorácia} práce s~dátami. Pri takomto postupe sa neuvažujú žiadne inštrukcie kde sa nastavuje hodnota dát a~všetky podmienky, ktoré porovnávajú dáta, sú nahradené inštrukciou \texttt{if*}. Tento prístup avšak môže viesť k~falošným protipríkladom (tvrdenie že program obsahuje chybu ak ju v~skutočnosti neobsahuje), ale nespôsobí falošné pozitíva (tvrdenie že neobsahuje chybu ak ju v~skutočnosti obsahuje).

\section{Tvorba programu v~ARTMC}
Tvorba programu pre nástroj ARTMC je zložitá, ľahko sa v~ňom tvoria chyby a~je komplikované
upravovať napísaný program.
Ako príklad uveďme jednoduchý program, ktorý by v~jazyku C mohol vyzerať nasledovne:

\code{%
while(x->next != NULL)\\
\tab x = x->next;
}

\noindent
Takýto program by sa do nástroja ARTMC prepísal ako:

\code{%
(``x=y.next'',``00000000'',2,1,0,1),\\
(``ifx==null'',``00000001'',2,4,2),\\
(``x=y.next'',``00000010'',1,1,0,3),\\
(``goto'',``00000011'',0)
}

\noindent
Okrem tohoto kódu avšak je potrebné napísať celú funkciu, ktorá vracia tento kód a~dané prostredie.
Teda celý vstupný súbor by vyzeral nasledovne.

\code{%
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab \tab (``ifx==null'',``00000001'',2,4,2),\\
\tab \tab (``x=y.next'',``00000010'',1,1,0,3),\\
\tab \tab (``goto'',``00000011'',0),\\
\tab \tab (``exit'',``00000100'')]   \# Na konci musí byť inštrukcia exit\\
\tab node\_width=16\\
\tab pointer\_num=3\\
\tab desc\_num=3\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)
}

\noindent
Ako je na prvý pohľad zrejmé, napísať program v~jazyku C je výrazne jednoduchšie ako pre nástroj ARTMC. Rovnako je v~jazyku C výrazne menšia šanca zavedenia chyby. Pri tvorbe programu v~nástroji ARTMC je potrebné počítať premenné a~správne ich značiť, počítať riadky pre pokračovanie inštrukcií atď.. Ešte zložitejšia je úprava kódu, kde len pridaním jednej malej zmeny je častokrát potrebné prepísať takmer celý program. Predstavme si, že sa rozhodneme mierne zmeniť predchádzajúci program na:

\code{%
while(x->next != NULL)\{\\
\tab x->next = malloc(sizeof(x));\\
\tab x = x->next;\\
\}
}

\noindent
výstup by sa výrazne zmenil. Podčiarknuté sú všetky riadky, ktoré sa zmenili alebo pribudli.

\code{%
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab \tab \underline{(``ifx==null'',``00000001'',2,5,2),}\\
\tab \tab \underline{(``x.next=new'',``00000010'',1,0,3,3,1),}\\
\tab \tab \underline{(``x=y.next'',``00000011'',1,1,0,4),}\\
\tab \tab \underline{(``goto'',``00000100'',0),}\\
\tab \tab \underline{(``exit'',``00000101'')]}\\
\tab \underline{node\_width=17}\\
\tab pointer\_num=3\\
\tab \underline{desc\_num=4}\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)
}

\chapter{Prekladače}
\label{kap_prekladace}
Prekladač je nástroj, ktorý číta zdrojový program a~prekladá ho na cieľový program.
Zdrojový a~cieľový program sú si vzájomne funkčne ekvivalentné\cite{meduna}.
Prekladač pozostáva z~viacerých častí. Schéma bežného prekladača je na obrázku \ref{fig:sch}.

\begin{figure}
\begin{center}
\begin{tikzpicture}[align=center, auto]
    % Place nodes
    \node [block] (lex) {Lexikálny analýzátor};
    \node [cloud, above=of lex, align=center] (zdroj) {Zdrojový\\program};
    \node [block, below=of lex, yshift=-1cm] (synta) {Syntaktický analyzátor};
    \node [block, right=of synta, xshift=3.0cm, align=center] (sema) {Sémantický\\analýzátor};
    \node [block, below=of synta] (gen) {Generátor vnútorného kódu};
    \node [block, below=of gen] (opti) {Op\-ti\-ma\-li\-zá\-tor};
    \node [block, below=of opti, align=center] (gen_ciel) {Generátor cieľového kódu};
    \node [cloud, below=of gen_ciel, align=center] (ciel) {Cieľový\\program};
    
    \node [label, left=of synta, xshift=-0.75cm, yshift=0.5cm] (xlbl) {};
    
    \node [label, left=of synta, xshift=0.3cm, yshift=0.5cm,align=center](lbl){Syntaxou\\riadený\\preklad};
    
    \node[draw,dashed, inner xsep=2em, inner ysep=2em, fit=(synta) (sema) (gen) (xlbl)] {};
    
    % Draw edges
    \path [line] (zdroj) -- (lex);
    
    \draw[->] (lex.230) -- node[near start, xshift=-1.25cm]{token} (synta.130);
    \draw[->] (synta.50) -- node[near end, xshift=2.25cm]{get\_token} (lex.310);
    
    \draw[->] (sema.163) -- node[yshift=0.5cm]{sémantická informácia} (synta.10);
    \draw[->] (synta.-10) -- node[]{sémantická kontrola} (sema.197.75);
    
    \path [line] (synta) -- node[]{generovanie inštrukcií} (gen);
    \path [line] (gen) -- node[]{vnútorný kód} (opti);
    \path [line] (opti) -- node[]{optimalizovaný kód} (gen_ciel);

    \path [line] (gen_ciel) -- (ciel);
    

\end{tikzpicture}
\caption{Schéma prekladača \cite{meduna}}
\label{fig:sch}
\end{center}
\end{figure}

\section{Lexikálny analyzátor}
\label{sec_lex}
Lexikálny analyzátor, scanner, má na vstupe program zapísaný v~zdrojovom jazyku. Tento program
je scannerom delený na lexémy - logicky oddelené lexikálne jednotky. Na výstupe je reťazec
tokenov, pričom token reprezentuje lexémy a~môže obsahovať ďalšie atribúty. \cite{meduna} 
Tento proces je znázornený v~obrázku \ref{fig:lex}.

\section{Syntaktický analyzátor}
Syntaktický analyzátor, parser, má na vstupe reťazec tokenov, ktoré získal
z~lexikálneho analyzátora. Úlohou je skontrolovať, či
reťazec tokenov reprezentuje syntakticky správne napísaný program. Táto kontrola
prebieha za pomoci konštrukcie derivačného stromu. Ak je možné zostrojiť derivačný strom
jedná sa o~program validný. Konštrukcia môže prebiehať dvoma spôsobmi a~to zhora
nadol a~zdola nahor\cite{meduna}. 

\subsection{Analýza zhora-nadol}
Metóda zhora-nadol sa snaží skonštruovať derivačný strom od najvyššej úrovne a~postupne prechádza derivačný strom dole za využita formálnych pravidiel gramatiky. To znamená, že derivačný strom sa konštruje od koreňa smerom k~listom, zľava doprava, poďla ľavej derivácie. Syntaktická analýza zhora dole využíva pre svoju prácu LL syntaktické analyzátory\cite{aho}.

\subsection{Analýza zdola-nahor}
Metóda zdola-nahor sa snaží skonštruovať derivačný strom od najnižšej úrovne a~postupne prechádza derivačný strom smerom ku koreni za využitia formálnych pravidiel gramatiky. To znamená, že sa najskôr identifikujú jednotlivé symboly, z~ktorých sa následne vytvára derivačný strom. Táto metóda využíva precedenčnú tabuľku\cite{aho}.

\begin{center}
\begin{figure}
\begin{tikzpicture}[auto]
	\node [small_block] (s3) {y};
	\node[single arrow,draw=black,fill=white,minimum height=1cm, shape border rotate=-180, above=of s3] (ar1) {};	
	
    \node [block, above=of ar1] (first) {x = y * 2};
    \node [small_block, left=of s3] (s2) {=};
    \node [small_block, left=of s2] (s1) {x};

    \node [small_block, right=of s3] (s4) {*};
    \node [small_block, right=of s4] (s5) {2};  
	   
	\node [data, below of=s1] (p1) {id \nodepart{second} x};    
	\node [data, below of=s2] (p2) {=};  
	\node [data, below of=s3] (p3) {id \nodepart{second} y};
	\node [data, below of=s4] (p4) {*}; 
	\node [data, below of=s5] (p5) {int \nodepart{second} 2};

	\node [label, left of=s1, xshift=-1cm] (t1) {Lexémy:};   
    \node [label, left of=p1, xshift=-1cm] (t2) {Tokeny:};  

\end{tikzpicture}
\caption{Schéma rozdeľovania na lexémy a~tokeny}
\label{fig:lex}
\end{figure}
\end{center}

\section{Sémantický analyzátor}
Na vstupe sémantického analyzátoru je derivačný strom, ktorý bol získaný od
syntaktického analyzátora. Sémantický analyzátor kontroluje sémantické aspekty
vstupného programu a~to hlavne 
\begin{itemize}
    \item kontrola typov
    \item kontrola deklarácií premenných
\end{itemize}
Na výstupe je abstraktný syntaktický strom.

\section{Generátor vnútorného kódu}
Generátor vnútorného kódu, ako názov napovedá, vytvára vnútornú reprezentáciu programu
z~abstraktného syntaktického stromu. Medzi hlavné dôvody, prečo je vhodné
vytvárať vnútorný kód patrí hlavne:
\begin{itemize}
    \item Priame vytváranie výstupného programu je nepriehladné
    \item Jednotnosť - všetky inštrukcie sa tvária rovnako
    \item Jednoduchá optimalizácia
\end{itemize}

\section{Optimalizátor}
Cieľom tejto časti je upraviť vnútorný kód to takej podoby, aby bol efektívnejší.
Medzi optimalizácie môžu patriť:
\begin{itemize}
    \item Eliminácia mŕtveho kódu
    \item Šírenie kopírovaným
    \item Šírenie konštanty
\end{itemize}

\section{Generátor cieľového kódu}
Generátor cieľového kódu prevádza vnútornú reprezentáciu programu do funkčne ekvivalentného cieľového programu a~teda ukončuje proces kompilácie. Tento posledný krok je závislý od cieľového jazyka ale aj konkrétnej platformy pre ktorú sa preklad vykonáva. Najčastejšie je cieľovým jazykom strojový kód alebo assambler, avšak je možný preklad aj medzi dvoma vyššími programovacími jazykmi\cite{meduna}. 

\section{Syntaxou riadený preklad}
\label{sec_synta}
Jedná sa o~prístup, keď celý preklad je riadený procesom parsovania. Teda ku každému pravidlu gramatiky sú priradené ďalšie akcie, ktoré pokrývajú ostatné fázy prekladu. Medzi akcie môže napríklad patriť:
\begin{itemize}
    \item Vyvolanie sémantickej kontroly
    \item Ukladanie informácií napr. do tabuľky symbolov alebo tabuľky návestí
    \item Generovanie kódu
\end{itemize}
Prevažne pri využití tejto techniky postačuje jeden priechod cez zdrojový program\cite{aho}.


\chapter{Súčasný stav prekladača pre ARTMC}
\label{kap_averiles}
Pre nástroj ARTMC bol vytvorený prekladač z~jazyka C vrámci projektu AVERILES\footnote{http://www.lsv.fr/Projects/rntl-averiles/}. Jedná sa
o~študentský projekt napísaný v~jazyku Java. Snahou tejto práce nie je tento prekladač
upraviť ale napísať úplne nový. Hlavné dôvody prečo je potrebné vytvoriť nový
prekladač sú:
\begin{itemize}
    \item Chyby v~prekladači\\
        Prekladač nedokáže spracovať určité výrazy. Niektoré výrazy sú prekladané nesprávne.
        Preto je potrebné pri zložitejších programoch manuálne kontrolovať výsledný
        program a~editovať vstupný program do takej formy, aby ho prekladač dokázal
        preložiť.
    \item Ťažko rozšíriteľný\\
        Prekladač je napísaný v~jazyku Java zložitým a~nečitateľným spôsobom. Takýto
        kód sa veľmi ťažko modifikuje a~rozširuje o~ďalšie vlastnosti. Prekladač,
        ktorý je výstupom tejto práce si dáva za cieľ čitateľný kód, do ktorého
        sa jednoducho dopĺňajú ďalšie funkcionality.
    \item Nepraktické používanie\\
        Proces prekladu za pomoci AVERILES pozostáva z~dvoch krokov:
        \begin{enumerate}
            \item Tvorba XML súboru zo zdrojového programu v~jazyku C
            \item Preklad XML súboru do vstupného formátu nástroja ARTMC
        \end{enumerate}
        Takýto postup je zložitejší, nakoľko je potrebné volať dva programy.
        Zároveň programy nemajú prepínače na modifikáciu ich správania, teda
        použitie je možné len v~jednom užívateľskom prípade.
\end{itemize}

\chapter{Návrh implementácie}
\label{kap_imp}
Táto kapitola sa venuje návrhu implementácie samotného prekladača.
Ako implementačný jazyk bol zvolený Python. Kritériá, ktoré by mala výsledná
aplikácia spĺňať sa dajú rozdeliť do troch kategórií:
\begin{enumerate}
    \item Použiteľnosť a~prenositeľnosť
    \item Udržiavateľnosť a~rozširovateľnosť
    \item Testovateľnosť
\end{enumerate}

\section{Použiteľnosť a~prenositeľnosť}
Výsledná aplikácia by mala byť jednoducho použiteľná. Tak ako bolo spomenuté
v~kapitole \ref{kap_averiles}, momentálne existujúci prekladač má nie jednoduché používanie. Zároveň
neumožňuje špecifikovať ďalšie voľby, ktoré by užívateľ mohol potrebovať. Medzi voľby,
ktoré by užívateľ mohol potrebovať mimo iné patria hlavne:
\begin{itemize}
    \item Možnosť špecifikovať výstupný súbor\\
        Výstupný súbor je implicitne uložený na rovnaké miesto ako vstupný a~je
        pomenovaný \texttt{program.py}. Avšak užívateľ si môže zvoliť ľubovoľné umiestenie
        a~názov súboru.
    \item Možnosť špecifikovať vstupný deskriptor\\
        Viď kapitola \ref{kap_descr}. Nakoľko sa vstupný deskriptor získava z~\texttt{get\_typedef\_descr.t.sh} a~je
        možné, že tento program nie je dostupný, aby sa dal preklad spustiť, môže
        užívateľ túto hodnotu poskytnúť.
    \item Možnosť ignorácie dát\\
        Nakoľko podpora práce s~dátami v~ARTMC je výrazne obmedzená, môže byť
        vhodné nechať prekladač aby prácu s~dátami neprekladal.Výsledok prekladu je potom avšak	  nadaproximáciou vstupu.
\end{itemize}

Rovnako medzi hlavné požiadavky patrí aj prenositeľnosť. V~rámci tohoto bodu
musíme uvažovať dva druhy prenositeľnosti:
\begin{itemize}
    \item Operačný systém\\
        Program by mal byť spustiteľný a~správne bežať aspoň na Linux-och a~Windows-och.
    \item Verzia Pythonu\\
        Program by mal byť spustiteľný a~správne bežať na všetkých hlavných verziách Pythonu.
        Viac o~Pythone a~verziách je v~kapitole \ref{subsec_python}.
\end{itemize}

\subsection{Python}
\label{subsec_python}
Python je vysokoúrovňový skriptovací programovací jazyk. Podporuje viacero programovacích
paradigmat. Pre túto prácu bude použité objektovo orientované. Zároveň Python podporuje
dynamickú typovú kontrolu.
Python má dve hlavné verzie. Python 2.X a~Python 3.X. Ďalej tieto verzie sa delia na podverzie.
Verzie a~podverzie nemusia byť (a~ani nie sú) medzi sebou kompatibilné. To prináša problém
pre programátorov, ktorý chcú písať program tak, aby fungoval pre rôzne verzie.
C2ARTMC by mal fungovať aspoň pre verzie \texttt{2.6, 2.7, 3.3, 3.4, 3.5}.

\section{Udržiavateľnosť a~rozširovateľnosť}
Program by mal byť napísaný tak, aby bolo možné neskôr dopĺňať ďalšiu funkcionalitu a~prípadne opravovať chyby. Mal by byť logicky rozdelený na menšie celky (moduly, triedy, funkcie). Očakáva sa dostatočná miera komentárov, aspoň pri každom celku. Tieto vlastnosti by mali umožniť jednoduchú orientáciu v~kóde a~teda schopnosť neskôr upravovať tento prekladač.

Okrem vyššie spomenutých vlastností v~projekt by mal byť program verzovaný za pomoci nástroja Git, ktorý umožňuje spoluprácu viacerých autorov ako aj sledovanie a~vyhľadávanie zmien v~celej histórii projektu.

\subsection{Git}
Verzovací systém Git umožňuje sledovať vývoj projektu a~v~jednotlivých zmenách
v~histórií sa posúvať. Teda v~prípade chyby je jednoduché zistiť kedy a~ako chyba
vznikla. Zároveň je jednoduché sa vrátiť do stavu pred chybou.
Git umožňuje rovnako jednoduchú spoluprácu viacerých autorov. Táto práca je dielom jedného autora, avšak je možné, že po dokončení práce sa nájde
chyba, alebo bude treba doplniť funkcionalitu a~to umožní aby iný autor túto zmenu
vykonal.

Táto práca využíva GitHub a~je dostupná na \texttt{https://github.com/marusak/C2ARTMC}.

\section{Testovateľnosť}
Vývoj väčších aplikácii si vyžaduje overovanie správnej funkcionality programu. Overovanie sa vykonáva za pomoci hromadných testov, kde jedným príkazom je vyvolaných viacero testov a~ako výsledok je poskytnuté zhrnutie zo všetkých testov. Táto práca takéto testy by mala obsahovať a~za využitia nástroja Tox by mala overovať správne fungovania aj na rôznych verziách Pythonu.

\subsection{Hromadné testy}
Pri pridávaní novej funkcionality sa môže stať, že sa zavedie chyba vrámci inej
funkcionality. Preto je vhodné po každej zmene otestovať všetky predtým
naprogramované vlastnosti. To je prirodzene takmer nemožné. Preto sa píšu testy,
ktoré sa dajú spúšťať hromadne a~je ľahko a~rýchlo možné overiť, že neprišlo
k~zavedeniu chyby. Rovnako je odporúčané na každú novú funkcionalitu napísať test, ktorý overí, že táto vlastnosť bola správne implementovaná. Neskôr tento test bude overovať, že táto funkcia stále funguje správne a~nebola narušená.

\subsection{Tox}
\label{sec_tox}
Aby bolo možné spúšťať testy pod rôznymi verziami Pythonu a~overiť, že všetky testy
uspejú na všetkých podporovaných verziách, v~práci bude použitý nástroj Tox.
Jedná sa o~program, ktorý potrebuje iba jeden jednoduchý konfiguračný súbor, ktorý
obsahuj spôsob ako sa spúšťajú testy a~verzie Pythonov, pod ktorými chceme
aby program fungoval. Následne zavolaním programu Tox sa testy
spustia pod všetkými požadovanými verziami a~prehľadný výpis oznámi, či všetky
testy boli úspešné, prípadne ktorý test neuspel v~ktorej verzii.


\chapter{Výsledná aplikácia}
Aplikácia bola vytvorená s~ohľadom na zadanie bakalárskej práce. Boli dodržané všetky body zadania. Pri vývoji boli dodržané vlastnosti kódu a~vývoja spomenuté v~kapitole \ref{kap_imp}. Hneď po vytvorení prvej skutočne funkčnej časti kódu boli vytvárané automatické testy pre overenie  funkcionality implementovaných častí a~overenie, že počas pridávania ďalších vlastností neprišlo k~regresii v~inej časti programu. 

Kód bol od začiatku publikovaný na GitHub-e s~ohľadom na odporúčané praktiky pri využívaní verzovacieho systému Git. História je prehľadná a~je možné v~nej jednoducho sa vracať alebo zisťovať ktorá časť kódu bola kedy a~prečo implementovaná.

Výsledný program bol poriadne otestovaný na sade testov. Pre zoznam testov viď prílohu \ref{priloha:testy}. Všetky testy prešli úspešne na všetkých požadovaných operačných systémoch ako aj verziách Pythonu.

\section{Výsledná implementácia}
V~tejto časti textu je popis implementácie. Jedná sa o~spojenie znalostí z~kapitoly \ref{kap_prekladace} o~prekladačoch so skutočne použitými vlastnosťami a~ich implementáciou v~jazyku Python.
\subsection{Lexikálny analyzátor}
Ako prvá časť bol implementovaný lexikálny analyzátor. Jedná sa o~samotnú triedu \texttt{Scanner}, ktorá v~inicializácii berie názov súboru z~programom v~jazyku C. Následne je vstupný program načítaný a~predspracovaný. Jedná sa hlavne o~odstránenie komentárov a~nahradenie skupín bielych znakov jednou medzerou. Tieto úpravy následne umožňujú jednoduchšie delenie kódu na tokeny. Trieda lexikálneho analyzátora poskytuje metódu \texttt{get\_token}, ktorá vráti práve jeden token. Na delenie sa nevyužívajú regulárne výrazy, ale podľa prvého neprečítaného znaku sa scanner rozhoduje o~aký token sa môže jednať. Následne po rozpoznaní tokenu, je vrátený token, ktorý je reprezentovaný jedným číslom - jedná sa o~imitáciu \texttt{enum} pre jazyk Python. Konkrétna hodnota tokenu sa nevracia priamo a~je možné ju získať volaním funkcie \texttt{get\_value}. Scanner poskytuje aj metódu \texttt{unget\_token}, ktorá vráti jeden token späť do vstupného reťazca. Nakoľko je ale scanner ako aj celý prekladač jednopriechodový, je táto funkcia implementovaná inštančnou premennou, ktorá drží vrátenú hodnotu. Výhodou je jednoduchá implementácia, teoretickou nevýhodou je možné vrátiť iba jeden token, avšak vrámci implementácie tohoto prekladača nebolo nikdy potrebné vracať viac za sebou idúcich tokenov.

\subsection{Syntaktický analyzátor}
Následne bol tvorený syntaktický analyzátor, ktorý je implementovaný ako trieda \texttt{Parser}. Jedná sa o~syntaxou riadený preklad a~preto je samotný analyzátor najdlhšia časť kódu. Napriek svojej veľkosti sa jedná o~pomerne jednoduchý program. V~princípe je celá analýza jeden while cyklus, ktorý čaká až skončí vstupný súbor a~\texttt{scanner} vráti \texttt{EOF}. V~tomto cykle sa prečíta prvý token a~na základe neho sa rozhodne o~aký príkaz sa jedná. V~tejto úrovni sa môže jednať iba o~definíciu alebo deklaráciu funkcie alebo premennej. Spracovanie premennej je priamočiara záležitosť. Spracovanie funkcie obsluhuje funkcia \texttt{parse\_function}, ktorá je obdobne jeden while cyklus, ktorý volá funkciu \texttt{parse\_command} až pokiaľ nenarazí na ukončujúcu zloženú zátvorku. Funkcia \texttt{parse\_command}
na základe prvého tokenu zavolá funkcie na spracovanie príkazu, napríklad \texttt{parse\_if} alebo \texttt{parse\_assignment}. Ak sa jedná o~príkaz, ktorý vytvára ďalšiu úroveň zanorenia ako napríklad \texttt{if} alebo \texttt{while}, celá úroveň je spracovaná touto funkciou za volania  \texttt{parse\_command} na spracovanie jednotlivých príkazov. Hovoríme teda o~rekurzívnom zanorovaní.

Ako bolo spomenuté v~sekcii \ref{sec_synta} ohľadom syntaxou riadenom preklade, počas syntaktickej analýzy sa vykonávajú aj ďalšie akcie. Medzi takéto akcie patrí napríklad vloženie premennej do tabuľky symbolov po nájdení novej premennej. Tabuľku symbolov vlastní trieda \texttt{Parser} a~poskytuje sadu inštrukcií na prácu s~ňou. Medzi ďalšie akcie patrí vygenerovanie inštrukcie vo vnútornom kóde po prečítaní celého príkazu. 

\subsection{Sémantický analyzátor}
Sémantický analyzátor nie je implicitne oddelený od zvyšku kódu ako je napríklad lexikálny alebo syntaktický analyzátor. Sémantická analýza sa vykonáva len v~tak obmedzenej forme, že všetky potrebné kontroly boli priamo zahrnuté do parsera. Hlavný dôvod málo kontrol súvisí s~nepodporovaním dát v~jazyku ARTMC a~teda takmer všetky inštrukcie, kde je potrebná sémantická analýza sa nevyskytujú vo vstupnom súbore. Je prirodzene ošetrené aj správanie v~prípade výskytu takejto konštrukcie. Toto správanie je opísané v~sekcii \ref{sec_features}.

\subsection{Generovanie kódu}
Na spracovanie vnútorného kódu bola vytvorená trieda \texttt{Generate}. Tento názov napovedá, že trieda nie len príma od parseru inštrukcie vo vnútornej reprezentácií, ale aj generuje cieľový kód. Trieda poskytuje celú radu funkcií pre vkladanie inštrukcií, ktoré začínajú prefixom \texttt{new\_i\_}. Okrem toho obsahuje funkciu \texttt{get\_full\_result}, ktorá má za úlohu vrátiť kód vo výstupnom jazyku pripravený na výpis alebo zápis do súboru. Táto funkcia volá všetky potrebné funkcie na generovanie a~dokončovanie inštrukcií z~vnútorného kódu do výsledného kódu.

Schéma fungovania výslednej implementácie je znázornená na obrázku \ref{fig:imp}.
\begin{center}
\begin{figure}[h]
\begin{tikzpicture}[auto,>=latex']

    \node [cloud, align=center] (vstup) {Vstupný\\program};
    \node [block, right=of vstup, xshift=1.5cm] (c2artmc) {c2artmc.py};
    \node [cloud, right=of c2artmc, align=center, xshift=3cm] (vystup) {Výstupný\\program};
    
    \node [block, below=of vystup, xshift=-1.75cm] (generate) {Generate};

    \path [line] (vstup) -- (c2artmc);

    \draw [->] (c2artmc.20) -- (vystup.160);
    \draw [->] (c2artmc.280) |- node[near start]{init} (generate.170);
    \draw [->] (c2artmc.-20) -| node[near start, yshift=-0.75cm, xshift=-0.25cm]{get\_full\_result} (generate.110);
    \draw [->, dashed] (generate.70) |- node[near start, xshift=3.5cm, yshift=-0.5cm]{výstupný program}  (c2artmc);
    
    \node [block, below=of vstup, xshift=1.75cm] (parser) {Parser};
    \draw [->] (c2artmc.260) |- node[near end]{run} (parser);
    \draw [->] (c2artmc.240) |- node[near end]{init} (parser.20);
    \draw [->] (parser.-20) |- node[near end, yshift=-0.5cm]{new\_i\_<instruction>}  (generate.200);
 
    \node [block, below=of parser, yshift=-1.5cm] (scanner) {Scanner};
    \draw [->] (parser.218) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{init} (scanner.142);
    \draw [->] (parser.240) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{get\_token} (scanner.120);
    \draw [->] (parser.275) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{unget\_token} (scanner.85);
    
        \draw [->, dashed] (scanner.50) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{token} (parser.310);
\end{tikzpicture}
\caption{Schéma fungovania implementovaného prekladača}
\label{fig:imp}
\end{figure}
\end{center}

\newpage
\section{Vstupný program}
Na vstupe sa očakáva platný program v~jazyku C s~určitými výnimkami. Výnimky môžme rozdeliť na štyri skupiny:\\
\begin{enumerate}
\item Nepodporované konštrukcie
\item Neštandardné podporované konštrukcie
\item Povinné položky
\item Nepovinné položky
\end{enumerate}

\subsection{Nepodporované konštrukcie}
Ako bolo spomenuté v~kapitole \ref{kap_artmc}, nástroj ARTMC má obmedzenú sadu príkazov a~preto nie je možné preložiť ľubovoľné konštrukcie. Avšak prekladač bol navrhnutý tak, aby nebolo nutné program príliš upravovať. Je to dosiahnuté tým, že príkazy, ktoré nemenia používané premenné sú preskočené. Viac o~tejto vlastnosti je v~podsekcii \ref{sec_features_jump}.

Z~významných konštrukcií nie sú podporované:
\begin{itemize}
\item \texttt{enum}
\item \texttt{for}
\item \texttt{union}
\end{itemize}

Medzi významné nepodporované konštrukcie patrí aj obmedzenie prác s~dátami. Tomuto obmedzeniu sa venuje sekcia \ref{sec_data}.

\subsection{Neštandardné podporované konštrukcie}
Okrem validných konštrukcií pre jazyk C boli implementované aj rozšírenia, ktoré sú potrebné pre nástroj ARTMC. Jedná sa hlavne o~podporu nedeterministického rozhodovania. V~jazyku C je túto konštrukciu možné zapísať ako \texttt{if(*)} alebo \texttt{if(any)}. Obe tieto konštrukcie sú preložené na príkaz \texttt{if*}.

Bola implementovaná aj podpora pre kľúčové slovo \texttt{ERROR}, ktoré sa môže vyskytnúť vrámci vrámci príkazu \texttt{return}. Tento príkaz sa preloží na príkaz \texttt{goto}. Ako miesto skoku je riadok vyskytujúci sa v~prostredí \texttt{env} \texttt{err\_line}. Príkaz \texttt{return ERROR} sa môže chápať ako ukončenie s~chybou, napríklad po neúspešnom allokovaní pamäte.

Posledná neštandardná vlastnosť pre implementovaný prekladač je podpora funkcie \texttt{random\_alloc(void)}. Táto funkcia sa preloží na príkaz \texttt{random\_position}. Využitím tejto funkcie je možné prinútiť nástroj ARTMC vybrať náhodný alokovaný uzol.

\subsection{Povinné položky}
Nástroj ARTMC implicitne predpokladá existenciu špecifickej štruktúry. Avšak počas návrhu prekladača bolo rozhodnuté, že prekladač nebude implicitne predpokladať existenciu žiadnej dátovej štruktúry a~bude vyžadovať, aby vždy bola presne zadaná pre každý program. Preto vstupný program musí obsahovať presne definovanú štruktúru. Príkladom môže byť štruktúra v~schéme \ref{fig:struct}. Za povšimnutie stojí existencia iba jednej neukazateľovej položky. Viac ako jedna dátová položka totižto nie je podporovaná zo strany nástroja ARTMC a~teda takúto štruktúru prekladač odmietne.
\begin{center}
\begin{figure}[H]
\code{%
typedef struct T1 \{\\                                                            
\tab struct T1* next;\\                                                            
\tab struct T1* prev;\\                                                          
\tab int data;\\                                                                   
\}* T;
}
\label{fig:struct}
\caption{Vzorový príklad štruktúry vo vstupnom programe}
\end{figure}
\end{center}

\subsection{Nepovinné položky}
Prekladač nepodporuje direktívu preprocesoru \texttt{\#include}. Avšak takéto riadky sú pri preklade ignorované, takže je možné ich tam ponechať. Preto je riadok \texttt{\#include <xxxxxx.h>} nepovinný aj napriek tomu, že v~zdrojovom kóde sa môžu vyskytovať kľúčové slová a~funkcie ktorú sú touto knižnicou podporované. V~tabuľke \ref{table:kniz} je výpis knižníc a~príkazov, ktoré z~nich sú podporované.

\begin{table}[H]
\centering
\begin{tabular}{c|l}
\textbf{Knižnica} & \textbf{Kľúčové slová a~funkcie} \\ \hline
stdlib.h          & NULL, malloc                      \\
assert.h          & assert                            \\
stdbool.h         & true, false                       \\
\end{tabular}
\caption{Implicitne podporované príkazy}
\label{table:kniz}
\end{table}


\section{Práca s~dátami}
\label{sec_data}
Vo vstupnom súbore nie sú podporované operácie nad dátovými premennými okrem priradenia a~porovnania. Je možné len priame priradenie a~nie je možné hodnotu meniť aritmetickými a~reťazcovými operáciami. Na takúto situáciu prekladač upozorní. Viď tabuľku \ref{table:working_not} pre lepšie porozumenie. Avšak je možné preložiť aj takýto program za pomoci ignorovania práce s~dátami.

\begin{table}[H]
\centering
\begin{tabular}{l|l}
\textbf{Príkaz} & \textbf{Podpora v~prekladači} \\ \hline
int x;          & OK                            \\
int x = 5;      & OK                            \\
x = 9;          & OK                            \\
x = y;          & OK                            \\
x = 14*3;       & ERROR                         \\
x += 2;         & ERROR                 
\end{tabular}
\caption{Možnosti práce s~dátami}
\label{table:working_not}
\end{table}

\subsection{Ignorovanie dát}
Počas vývoja a~testovania prekladača sa vyskytol problém pri práci s~dátami. Na vstupe sa objavil validný program, ktorý by mohol byť korektne preložený, avšak kvôli čo i~len jednému príkazu manipulujúcemu s~dátovou premennou nemohol byť tento program preložený. Často sa jednalo o~prácu s~premennou, ktorá nebola nijak potrebná pre analýzu nástrojom ARTMC. Ako príklad uvádzam nasledujúci program:

\code{%
x->data = 1;\\
\dots \\
\textit{ numerické operácie s~hodnotou x->data, napr.  \uv{x->data += 1;} }\\
\dots\\
if (x->data < 0)\\
\tab x->next = y;
}

\noindent
V~horeuvedenom programe sa manipuluje s~dátovou položkou štruktúry. Takéto operácie nie sú podporované zo strany nástroja ARTMC a~preto by tento program nemohol byť preložený. Avšak ak používateľ prekladača uzná, že tieto manipulácie a~podmienka nie sú kritickým rozhodovacím miestom a~teda vynechanie zmien dátovej položky a~nahradenie podmienky za nedeterministickú je možné, môže použiť prepínač \texttt{-i}, ktorý vynúti neprekladanie všetkých operácií, ktoré manipulujú s~dátami a~všetky podmienky obsahujúce porovnávanie dátové položky sa zmenia na nedeterministickú podmienku \texttt{if*}.

\subsection{Využitie štandardných premenných}
Okrem podpory priameho priraďovania dát do dátovej položky štruktúry je možné použiť priradenie aj zo štandardnej dátovej položky. Príklad použitia je znázornení na nasledujúcom kuse kódu:

\code{%
int i~= 0;\\
x->data = i;
}

\noindent
Obdobne je možné použiť štandardnú dátovú premennú aj v~podmienke ako je vidieť v~nasledujúcej ukážke:

\code{%
int i~= 0;\\
x->data = 1;\\
if (x->data == i)\\
\tab return ERROR;
}

\noindent
Avšak rovnako ako pri práci s~dátami priamo, ani v~tomto prípade nie je možné numericky a~reťazcovo meniť hodnotu premennej (viď tabuľku \ref{table:working_not}).

\section{Použitie aplikácie}
Prekladač poskytuje viacero prepínačov, ktorými je možné upraviť implicitné správanie.  Nasleduje výpis \texttt{c2artmc.py -{}-help}, ktorý ukazuje možné použitie tohto nástroja.
\begin{verbatim}
usage: c2artmc.py [-h] [-o O] [-d D] [-i] INPUT_FILE

Converter from C to ARTMC.

positional arguments:
 INPUT_FILE  C source file to be converted

optional arguments:
  -h, --help  show this help message and exit
  -o O~Filepath to write the ARTMC file
  -d D        Initial pointer descriptor
  -i          Ignore data
\end{verbatim}

\section{Neštandardné vlastnosti}
\label{sec_features}
V~tejto kapitole sú popísané vybrané vlastnosti prekladača, ktoré sú navrch zadania a~implementujú užitočné vlastnosti.
\subsection{Preskakovanie (častí) príkazov}
\label{sec_features_jump}
Nakoľko nástroj ARTMC neobsahuje žiadnu podporu pre volanie funkcií je nutné byť schopný adekvátne zareagovať na výskyt volania funkcie. Riešením je ohlásiť chybu pri nájdení volania funkcie. Avšak počas testovania sa ukázalo, že výhodnejšie je priamo takéto príkazy preskakovať. Preto bol na toto správanie prekladač upravený. Momentálne prekladač upozorní na fakt, že sa volanie funkcie preskakuje. Očakáva sa od používateľa, že na tieto varovania zareaguje a~ak niektorá funkcia menila premenné podstatné pre analýzu tak tieto príkazy adekvátne upraví.

Prekladač rovnako preskakuje aj časti príkazov, ak dopredu vie, že nesledujúcu informáciu nepotrebuje. Jedná sa napríklad o~príkaz \texttt{return}. Ak sa za príkazom \texttt{return} nevyskytuje kľúčové slovo \texttt{ERROR} tak prekladač môže zahodiť zvyšok príkazu. Obdobne to funguje aj pri funkciách \texttt{malloc} a~\texttt{random\_alloc} kde ich argumenty sú neprekladané.
\newpage

\subsection{Preklad viacnásobných pointrov}
V~prekladači je implementovaná podpora pre preklad viacnásobného prístupu cez ukazateľ či sa už jedná o~zápis alebo čítanie. Je teda možné preložiť príkaz typu:

\code{%
x->next->next = y->prev->next->prev;
}

\noindent
Nakoľko nástroj ARTMC nemá podporu pre takýto prístup, je nutné príkaz rozdeliť na viacero jednoduchých príkazov. Vyššie uvedený program by sa teda dal za pomoci pomocných premenných napísať ako:

\code{%
tmp1 = x->next;\\
tmp2 = y->prev;\\
tmp3 = tmp2->next;\\
tmp4 = tmp3->prev;\\
tmp1->next=tmp4;
}

\noindent
čo už je možné preložiť aj do nástroja ARTMC.

\subsection{Vyhodnocovanie neúplných podmienok}
V~jazyku C sa ako nepravda v~podmienke považuje číslica \texttt{0} rovnako ako aj ukazateľ \texttt{NULL}. Tento fakt sa často využíva pri zápise podmienok, kde podmienka typu \texttt{if (x)} je totožná s~podmienkou \texttt{if (x != NULL)}. Obdobne sa to dá využiť aj pri číslach a~teda podmienka \texttt{if (!x)} je totožná s~podmienkou \texttt{if (x == 0)}.

Podpora takéhoto zápisu bola implementovaná aj do vytváraného prekladača. Umožňuje to prekladať väčšiu škálu existujúcich programov v~jazyku C bez ich upravovania.

Samotná implementácia využíva možnosť vrátenia prečítaného tokenu späť do zoznamu tokenov. Pri spracovaní podmienky keď je očakávané znamienko rovnosti alebo nerovnosti a~namiesto toho je nájdená pravá zátvorka (znamená koniec podmienky), logický operátor alebo identifikátor tak sa tento prečítaný token vráti späť a~vygeneruje sa podmienka podľa jej prvej časti.

\subsection{Skratové vyhodnocovanie podmienok}
V~jazyku C je zaužívané využívať skratové vyhodnocovanie podmienok pre jednoduchší zápis. Veľmi často sa tento prístup používa práve pri dynamicky viazaných dátových štruktúrach. Pre lepšie porozumenie uveďme príklad:

\code{%
if (x \&\& x->next)\{\\
\tab x->next->next = y;\\
\}
}

\noindent
Pri tomto zápise máme istotu, že nepristúpime alebo nezapíšeme do nealokovaného uzla, nakoľko sa najskôr overí, že je  alokované \texttt{x} a~ak je tak potom sa overí aj dostupnosť \texttt{x->next}. A~iba ak oba uzly sú alokované, môžme bezpečne zapísať aj do \texttt{x->next->next}.

Implementovaný prekladač dokáže takéto podmienky preložiť. Je k~tomu použitý relatívne jednoduchý algoritmus, ktorý rozdelí výraz na podvýrazy a~podvýrazy zhlukuje do skupín podľa logických operátorov. Následne sa prechádza cez skupiny \texttt{or}-ov a~\texttt{and}-ov. Pre skupinu podvýrazov oddelených \texttt{||} platí, že po úspechu jednotlivých podvýrazov sa pokračuje za posledným podvýrazom v~skupine a~pri neúspechu nasledujúcim. Pri skupine spojenej logickým operátorom \texttt{\&\&} je to presne naopak. Tento algoritmus je znázornený na obrázku \ref{fig:scrat} kde čiarkovane sú označené podvýrazy, bodkovane skupiny, plnou šípkou splnenie podmienky a~čiarkovanou šípkou nesplnenie.

\begin{center}
\begin{figure}[h]
\begin{tikzpicture}[auto,>=latex', node distance=1mm]

    \node [subexpression] (t1) {p1};
    \node [operand, right=of t1] (l1) {\&\&};
    \node [subexpression, right=of l1] (t2) {p2};
    \node [operand, right=of t2] (l2) {\&\&};
    \node [subexpression, right=of l2] (t3) {p3};
    \node [draw,dotted, ellipse, inner xsep=-2.2em, inner ysep=0.5em, fit=(t1) (l1) (t2) (l2) (t3)] {};
    
	\draw [->] (t1) to [out=30,in=150] (t2);
	\draw [->] (t2) to [out=30,in=150] (t3);


    \node [operand, right=of t3] (l3) {||};
    \node [subexpression, right=of l3] (t4) {p4};
    \node [operand, right=of t4] (l4) {||};
    \node [subexpression, right=of l4] (t5) {p5};
    \node [draw,dotted, ellipse, inner xsep=-1.4em, inner ysep=0.1em, fit=(l3) (t4) (l4) (t5)] {};    
    \draw [->,dashed] (t3) to [out=30,in=150] (t4);
    \draw [->,dashed] (t1) to [out=45,in=135] (t4);
    \draw [->,dashed] (t2) to [out=45,in=140] (t4);
    

    \node [operand, right=of t5] (l5) {\&\&};
    \node [subexpression, right=of l5] (t6) {p6};
    
     \node [draw,dotted, ellipse, inner xsep=-0.85em, inner ysep=0em, fit=(l5) (t6)] {}; 
     \draw [->] (t3) to [out=315,in=240] (t6);
     \draw [->] (t4) to [out=315,in=230] (t6);
     \draw [->,dashed] (t4) to [out=30,in=150] (t5);
     
     \node [subexpression, right=of t6, fill=black!30, yshift=-1cm] (T) {True};
     \node [subexpression, right=of t6, fill=black!30, yshift=1cm] (F) {False};
     
     \draw [->,dashed] (t5) to [out=30,in=180] (F);
     \draw [->] (t5) to [out=315,in=220] (t6);
     
     \draw [->,dashed] (t6) to [out=10,in=270] (F);
     \draw [->] (t6) to [out=-10,in=90] (T);
     
\end{tikzpicture}
\caption{Schéma fungovania prekladu skratového vyhodnocovania}
\label{fig:scrat}

\end{figure}
\end{center}

\section{Testy}
Na overenie funkcionality prekladača boli vytvorené testovacie vstupné súbory. Jedná sa o~sadu programov v~jazyku C, ktoré obsahujú rôzne konštrukcie. Cieľom je overiť, že preklad vyprodukuje rovnaký kód, aký je očakávaný. Všetky očakávané programy v~jazyku pre nástroj ARTMC sú taktiež súčasťou testov. Zoznam testov je uvedený v~prílohe \ref{priloha:testy}.

Testy boli produkované postupne a~pre každú dôležitú zmenu bol vytvorený test, ktorý testoval tú danú konštrukciu. Zároveň existujúce testy overili, že zmenou kódu neboli zanesené žiadne chyby.

Aby bolo možné testovať prenosieľnosť programu medzi rôznymi verziami Pythonu, bol využitý nástroj tox. Funkcionalita tohoto nástroja je popísaná v~podsekcii \ref{sec_tox}.

\section{Navrhovaná práca}
Všetky požadované vlastnosti pre výslednú aplikáciu boli implementované. Avšak je možné, že časom si používanie ARTMC bude vyžadovať ďalšie funkcie, napríklad nové konštrukcie z~jazyka C a~teda bude potrebné daný kód doplniť.

\chapter{Záver}
Cieľom tejto práce bol návrh a~implementácia prekladača z~jazyka C do jazyka pre nástroj ARTMC. Text práce, ako aj samotná práca sa dá rozdeliť do dvoch častí, teoretickej a~praktickej. Vrámci praktickej časti bol naštudovaný nástroj ARTMC hlavne  z~pohľadu používania so zameraním na formát vstupu. Následne boli preštudovaná a~analyzovaná tvorba prekladačov. Po výbere technológií a~postupov pri tvorbe prekladača sa prešlo k~časti praktickej - implementácií samotného prekladača.

Ako implementačný jazyk bol zvolený Python. Program sa vyznačuje objektovo orientovaným prístupom, čistou kódu a~nezávislosťou ako na verzii Pythonu tak na neštandardných balíčkoch. Samotný kód je rozdelený na viacero modulov podľa jednotlivých celkov prekladača (scanner, parser, generátor kódu). Do prekladača bolo implementovaných viacero neštandardných a~pokročilých funkcionalít, ktoré tvoria prekladač ako aj nástroj ARTMC lepšie použiteľným.

Na overenie správnej funkcionality bolo vytvorených 16 komplexných testov. Každý test testuje celý priebeh prekladu. Testy je možné spúšťať naraz. Rovnako je možné spustiť všetky testy pre vybrané verzie Pythonu cez nástroj Tox.

Aplikácia spĺňa všetky požiadavky zadania a~implementuje aj funkcionalitu navyše. Aplikáciu plánujem aj naďalej udržiavať a~v~prípade chyby alebo potreby pre ďalšiu funkcionalitu tieto zmeny vykonať. Aplikácia je verejne dostupná v~službe GitHub a~preto je možné aby záujemcovi taktiež vykonávali zmeny.


%=========================================================================
