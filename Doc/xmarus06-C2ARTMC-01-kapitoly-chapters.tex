%=========================================================================
% (c) Michal Bidlo, Bohuslav Křena, 2008

\chapter{Úvod}
Verifikácia programov, teda overovanie že program spĺňa určité požiadavky, je v dnešnej dobe veľmi žiadaná. Napriek záujmu zo strán tvorcov softvéru neexistuje skutočne univerzálne a dokonalé riešenie. Avšak mnoho subjektov vytvára verfikátory, ktoré dokážu kontrolovať určité požadované vlastnosti programov.

Jedným z aktívnych subjektov pre verifikáciu a automatizovanú analýzu je aj výskumná skupina VeriFit na Vysokom Učení Technickom v Brne. Skupina se zaoberá základným výskumom, ale taktiež aj vývojom prototypových verifikačných nástrojov. Jedným z takýchto nástrojov je aj ARTMC.

Cieľom tejto práce je implementovať prekladač, ktorý dokáže z validného programu napísanom v jazyku C vytvoriť validný funkčne rovnaký program pre nástroj ARTMC. Takýto prekladač je potrebný z dôvodu zložitého zápisu programov v jazyku pre nástroj ARTMC. ARTMC bol hlavne vyvíjaný na ukázanie možností verifikácie programov, ktoré pracujú s dynamicky viazanými dátovými štruktúrami. Počas vývoja sa nekládol dôraz na použiteľnosť ale skôr na funkčnosť, čo ma za následok pre ľudí veľmi obtiažne tvoriteľný vstupný formát.

Prekladač by mal byť dostatočne robustný aj napriek veľmi malej podmnožine jazyka C ktorú je nástroj ARTMC schopný spracovať. V prípade konštrukcie, ktorá nie je podporovaná zo strany ARTMC sa zachovať adekvátne, či to už znamená skončenie chybou a oznámením čo konkrétne nie je možné spracovať, alebo dané príkazy preskočiť. Ďalej sa očakáva čitateľnosť a udržiavateľnosť napísaného prekladača pre ďalšie vylepšovanie a dopĺňanie funkcionality. V neposlednom rade je dôležitá prenositeľnosť.


\chapter{Nástroj ARTMC}
\label{kap_artmc}
ARTMC je nástroj na formálnu verifikáciu programov, ktoré manipulujú s
dynamicky viazanými dátovými štruktúrami. Tento nástroj bol vyvinutý na Fakulte
Informatiky Vysokého Učení Technického v Brne vrámci výskumnej skupiny VeriFit,
ktorá sa zaoberá verifikáciou programov. V tejto kapitole je tento nástroj
popísaný z dvoch hľadísk. Najskôr je stručný prehľad funkcionality jazyka a
následne je popísaná štruktúra vstupného súboru, ktorý je pre túto prácu
najdôležitejší.

\section{Funkcionalita a použitie ARTMC}
Majme na vstupe nerekurzívny program, ktorý manipuluje s dynamicky viazanými
štruktúrami s viacnásobnými next ukazateľmi. Snahou nástroja je overiť, že
nemôžu nastať nedovolené operácie (napr. zápis do null ukazateľa, použitie
nedefinovaného alebo už zmazaného prvku atď.)\cite{artmc1}.

Verifikačná metóda, ktorá je použitá v tomto nástroji je založená na abstraktom
regulárnom stromovom model checkingu \cite{artmc2}.

Schéma fungovania nástroja ARTMC je znázornená na obrázku \ref{fig:ARTMC_schema}.


\begin{figure}
\begin{tikzpicture}[align=center, node distance = 1cm and 0.5cm, auto, >=latex']
    % Place nodes
    \node [block] (program) {program.py};
    \node [block, below=of program] (typedef) {typedef};
    
    \node [block, right=of program, fill=black!30] (generator) {run\_generator.t.sh};
    \node [block, right=of typedef, fill=black!30] (parse) {parse\_typedef.t.sh};
        
    \node [small_w_block, right=of generator] (f3) {$f_n.gta$};
    \node [small_w_block, above=of f3] (f2) {$f_2.gta$};
    \node [small_w_block, above=of f2, yshift=-0.5cm] (f1) {$f_1.gta$};
    
    \node [small_w_block, right=of parse] (x3) {$init.gta$};
    \node [small_w_block, below=of x3, yshift=0.5cm] (x2) {$descr_1.gta$};
    \node [small_w_block, below=of x2] (x1) {$descr_n.gta$};

    \node [block, right=of x3, yshift=1.0cm, fill=black!30] (run) {main2\_\textit{method}};

	\draw [->] (program) |-++(1.5,-1.0) -| (parse);
    \path [line] (program) -- (generator);
    \path [line] (typedef) -- (parse);
    \path (f2) -- node[auto=false]{\vdots} (f3);
    \path (x1) -- node[auto=false]{\vdots} (x2);
    
    \path [line] (generator) |- (f1);
    \path [line] (generator.70) |- (f2);
    \path [line] (generator) |- (f3);
    
    \path [line] (parse) |- (x1);
    \path [line] (parse.290) |- (x2);
    \path [line] (parse) |- (x3);
    
    \path [line] (x1) -| (run.290);
    \path [line] (x2) -| (run);
    \path [line] (x3) -| (run.250);
    \path [line] (f1) -| (run.70);
    \path [line] (f2) -| (run);
    \path [line] (f3) -| (run.110);
        
    \node [cloud, right=of run, fill=black!30] (anal) {analýza};
    
    \path [line] (run) -- (anal);

\end{tikzpicture}
\caption{Schéma práce nástroja ARTMC}
\label{fig:ARTMC_schema}

\end{figure}


\section{Formát vstupného súboru}
Nástroj ARTMC potrebuje pre svoju analýzu dva súbory. Jedná sa o súbor \texttt{typedefs}, ktorý obsahuje definíciu množiny počiatočnej konfigurácie a súbor \texttt{program.py} obsahujúci definíciu programu vo formáte vytvorenom pre potreby tohto nástroja.

\subsection{typedefs}
Tento súbor sa používa na špecifikáciu množiny počiatočnej konfigurácie. Súbor obsahuje množinu typov. Následne sa pamäť zostavuje z uzlov špecifikovaných typov, ktoré sú prepojené za pomoci selektorov.

Existujú dva druhy selektorov:
\begin{itemize}
\item \textit{Priame spojenia}
\item \textit{Nepriame spojenia} sú popísané za pomoci cesty cez priame spojenia. Za pomoci symbola ``-'' pred priamym spojením sa značí nasledovanie spojenia späť.
\end{itemize}

Súbor typedefs pre obojsmerne viazaný list by mohol vyzerať nasledovne: \textit{(+ znamená \uv{alebo})}

\texttt{
typedef struct Tinit\\                                                            
/*? x ?*/\\                                                                       
\{\\
  struct T2 * next ;\\                                                           
  struct T2 * back ; /*? null ?*/\\                                               
\};
                                                                                \\
typedef struct T2                                                           
\{\\
  struct T2 * next ; /*? null ?*/\\                                               
  struct Any * back ; /*? -next ?*/\\
\}
+
\{\\
  struct T2 * next ;\\                                                           
  struct Any * back ; /*? -next ?*/\\                                             
\};
}

\subsection{program.py}
Zdrojový súbor obsahujúci jednu funkciu v jazyku Python, ktorá vracia dvojicu \texttt{(program, env)}.
Prvý prvok \textit{program} je zoznam n-tíc, kde každá n-tica je jeden príkaz jazyka ARTMC. V tabuľke \ref{table:prikazy} sú popísané jednotlivé podporované konštrukcie.
\begin{table}[]
\begin{tabular}{ll}
x:=null             & (``x=null'',``line\_num'',x,next\_line)\\
x:=y                & (``x=y'',``line\_num'',x,y,next\_line)\\
x:=y.next           & (``x=y.next'',``line\_num'',x,y,next,next\_line)\\
x.next=y            & (``x.next=y'',``line\_num'',x,y,next,next\_line,descr\_num)\\
if x==NULL          & (``ifx==null'',``line\_num'',x,next\_line\_then,next\_line\_else)\\
if x==y             & (``ifx==y'',``line\_num'',x,y,next\_line\_then,next\_line\_else)\\
if *                & (``if*'',``line\_num'',next\_line\_then,next\_line\_else)\\
goto                & (``goto'',``line\_num'',next\_line)\\
exit                & (``exit'',``line\_num'')\\
x.next=null         & (``x.next=null'',``line\_num'',x,next,next\_line)\\
x.next=new           & (``x.next=new'',``line\_num'',x,next,next\_line, descr\_num, gen\_descr)\\
setdata             & (``setdata'',``line\_num",x,``data'',next\_line)\\
if x.data==``\dots'' & (``ifdata'',``line\_num'',x,``data'',next\_line\_then,next\_line\_else)\\
x:=random\_position & (``x=random'',``line\_num'',x,next\_line)\\
new                 & (``new'',``line\_num'',x,next\_line)\\
\end{tabular}[]
\caption{Podporované príkazy v ARTMC}
\label{table:prikazy}
\end{table}
\subsection{Popis príkazov jazyka pre ARTMC}
\begin{itemize}
    \item \textit{Identifikátor} - Prvá položka je vždy reťazec obsahujúci identifikátor inštrukcie.
    \item \textit{Číslo príkazu} - Druhá položka značená ako \textit{line\_num} identifikuje príkaz
        vrámci celého programu. Jedná sa o reťazec skladajúci sa z postupnosti
        núl a jedničiek, ktorý musí byť vrámci celého  programu jedinečný.
        Ideálny postup je číslovať inštrukcie od 0 až po N a previesť tieto
        čísla do binárnej podoby. Zároveň je dôležité, aby všetky výsledné binárne čísla mali rovnako znakov.
    \item \textit{Premenné} - Označené ako \textit{x} a \textit{b}. V programe sú značené prirodzenými číslami.
    \item \textit{Ukazateľové premenné} - Označené ako \textit{next}. V programe sú číslované od 0.
    \item \textit{Ukazateľ na dalšiu inštrukciu} - Označené ako \textit{next\_line}. Označuje
        číslo riadku inštrukcie, na ktorej sa po skončení bude pokračovať. Inštrukcie
        sú číslované od nuly. Ak je použitá prípona \textit{\_then} alebo \textit{\_else}
        jedná sa o miesto pokračovania v prípade splnenia alebo nesplnenia podmienky danej inštrukcie.
    \item \textit{Deskriptory 1} - Označené ako \textit{descr\_num}. Jedinečný deskriptor použitý pri vykonávaní danej inštrukcie. Deskriptory sú číslované od 1. Viac o nastavovaní hodnôt tohto deskriptoru je v podsekcii \ref{kap_descr}.
    \item \textit{Desktirpty 2} - Označené ako \textit{gen\_num}. Využíva sa iba pri príkaze \texttt{x.next=new} a označuje automatickú generáciu počiatočného deskriptoru. Nadobúda hodnoty 0 (vypnuté) a 1 (zapnuté).
\end{itemize}

\subsection{env}
Jedná sa o 6ticu \texttt{node\_width, pointer\_num, desc\_num, next\_num, err\_line, restrict\_var} obsahujúcu informácie o programe.
Význam jednotlivých položiek je nasledovný:

\begin{itemize}
\item \texttt{node\_width = pointer\_num + descr\_num + 2 + } šírka dát  
\item \texttt{pointer\_num} = Počet ukazateľových premenných zvýšený o 1
\item \texttt{desc\_num} = Počet ukazateľových deskriptorov zvýšený o 1. Viac v podsekcii\ref{kap_descr}.
\item \texttt{next\_num} = Počet next pointerov použitých v programe
\item \texttt{err\_line} = Označenie riadku, na ktorý sa skáče v prípade chyby.
\item \texttt{restrict\_var} = Automatické generovanie automatu, ktorý garantuje iba jeden výskyt programovej premennej v konfigurácii. Nadobúda hodnoty 0 (vypnuté) a 1 (zapnuté).
\end{itemize}


\subsection{Nastavovanie deskriptoru}
\label{kap_descr}
Deskriptor pozostáva z dvoch častí:
\begin{enumerate}
\item Deskriptory v konfigurácii - Jedná sa o deskriptory, ktoré sú použité v súbore \textit{typedefs}. Tieto deskriptory už nemôžu byť znova použité. Číslo najvyššieho použitého deskriptoru je možné získať zo skriptu \texttt{get\_typedef\_descr.t.sh}, ktorý je šírení v distribúcii ARTMC.
\item Vlastné deskriptory - Každý príkaz typu \texttt{x.next=y} alebo \texttt{x.next=new} dostane vlastný deskriptor, ktorý ešte nebol použitý. Nemôže byť použitý ani v konfigurácii.
\end{enumerate}

\subsection{Podpora práce s dátami v ARTMC}
Jazyk pre nástroj ARTMC obsahuje iba dve inštrukcie pre prácu s dátami. Jedná sa o príkazy \texttt{setdata} a \texttt{ifdata}. Existujú teda iba funkcie na priradenie hodnoty a na porovnanie hodnoty. Ako si je možné v tabuľke \ref{table:prikazy} všimnúť, tieto funkcie berú iba jednú premennú \texttt{x}. Je to preto, lebo sa predpokladá, že štruktúra, ktorej je premenná \texttt{x} má práve jednu dátovú položku. V jazyku C môžu tieto dáta byť ľubovoľného typu, avšak pre ARTMC musia byť kódované ako postupnosť núl a jedničiek. Na skutočnej reprezentácii v binárnej podobe nezáleží, tak je napríklad vhodné prvým dátam dať napr. 	``00000001'' ďalším ``00000010'' atď. Je len potrebné aby rovnaká hodnota nebola kódovaná viackrát pod rôznymi kódmi.

Problematické je avšak spracovanie zložitejších výrazov nakoľko neexistujú funkcie na sčítanie, odčítanie a pod.. Teda napríklad výraz\\
\tab \texttt{if (x->data - 1 > y->data)}\\
sa nedá zapísať do nástroja ARTMC. Je možná určitá analýza a za pomoci sledovania šírenia konštánt alebo úpravy výrazov je možné niektoré konštrukcie preložiť. Napríklad kód:\\
\texttt{
if (x->data -1 == 0)\\
\tab \dots
}  

\noindent
po úprave výrazu je možné prepísať ako:\\
\texttt{
if (x->data == 1)\\
\tab \dots
}  

\noindent
a napríklad kód:\\
\texttt{
y->data = 0\\
\dots \textit{ak sa nezmení y a ani y->data}\\
if (x->data == y->data)\\
\tab \dots
}  

\noindent
po sledovaní šírenia konštánt je možné zaísať ako:\\
\texttt{
y->data = 0\\
\dots\\
if (x->data == 0)\\ 
\tab \dots
}  

Avšak takéto úpravy nie sú vždy možné, hlavne ak sa upravujú hodnoty vo while cykloch. Potom ostáva už len \textit{ignorácia práce s dátami}. Pri takomto postupe sa neuvažujú žiadne inštrukcie kde sa nastavuje hodnota dát a všetky podmienky, ktoré porovnávajú dáta sú nahradené inštrukciou \texttt{if*}.

\section{Tvorba programu v ARTMC}
Tvorba programu pre nástroj ARTMC je zložitá, ľahko sa v nom tvoria chyby a je zložité
upravovať napísaný program.
Ako príklad uveďme jednoduchý program, ktorý by v jazyku C mohol vyzerať nasledovne:\\
\noindent
\texttt{
\\
while(x->next != NULL)\\
\tab x = x->next;
\\
}
\noindent
Takýto program by sa do nástroja ARTMC prepísal ako:\\
\texttt{ 
\\
\tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab (``ifx==null'',``00000001'',2,4,2),\\
\tab (``x=y.next'',``00000010'',1,1,0,3),\\
\tab (``goto'',``00000011'',0),\\
}

Okrem tohoto kódu avšak je potrebné napísať celú triedu, ktorá vracia tento kód a dané prostredie.
Teda celý vstupný súbor by vyzeral nasledovne.


\texttt{
\\
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\tab \tab (``ifx==null'',``00000001'',2,4,2),\\
\tab \tab (``x=y.next'',``00000010'',1,1,0,3),\\
\tab \tab (``goto'',``00000011'',0),\\
\tab \tab (``exit'',``00000100'')]   \# Na konci musí byť inštrukcia exit\\
\tab node\_width=16\\
\tab pointer\_num=3\\
\tab desc\_num=3\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)
}

Ako je na prvý pohľad zrejmé, napísať program v jazyku C je výrazne jednoduchšie ako pre nástroj ARTMC. Rovnako je v C značne menšia šanca zavedenia chyby. Pri tvorbe v ARTMC je potrebné počítať premenné a správne ich značiť, počítať riadky pre pokračovanie inštrukcií atď.. Ešte zložitejšia je úprava kódu, kde len pridaním jednej drobnej zmeny je častokrát potrebné prepísať takmer celý program. Predstavme si že sa rozhodneme mierne zmeniť predchádzajúci program na:\\
\noindent
\texttt{
\\
while(x->next != NULL)\{\\
\tab x->next = malloc(sizeof(x));\\
\tab x = x->next;\\
\}
\\
}

Výstup by sa výrazne zmenil. Podčiarknuté sú všetky riadky, ktoré sa zmenili alebo pribudli.


\texttt{
\\
def get\_program()$\colon$\\
\tab program=[\\
\tab \tab (``x=y.next'',``00000000'',2,1,0,1),\\
\underline{\tab \tab (``ifx==null'',``00000001'',2,5,2),}\\
\underline{\tab \tab (``x.next=new'',``00000010'',1,0,3,3,1),}\\
\underline{\tab \tab (``x=y.next'',``00000011'',1,1,0,4),}\\
\underline{\tab \tab (``goto'',``00000100'',0),}\\
\underline{\tab \tab (``exit'',``00000101'')]}\\
\underline{\tab node\_width=17}\\
\tab pointer\_num=3\\
\underline{\tab desc\_num=4}\\
\tab next\_num=1\\
\tab err\_line="11111111"\\
\tab restrict\_var=1\\
\tab env=(node\_width, pointer\_num, desc\_num, next\_num, err\_line,restrict\_var)\\
\tab return(program, env)
}

\chapter{Prekladače}
\label{kap_prekladace}
Prekladač je nástroj, ktorý číta zdrojový program a prekladá ho na cieľový program.
Zdrojový a cieľový program sú si vzájomne funkčne ekvivalentné\cite{meduna}.
Prekladač pozostáva z viacerých častí. Schéma bežného prekladača je na obrázku \ref{fig:sch}.


\begin{figure}
\begin{center}
\begin{tikzpicture}[align=center, auto]
    % Place nodes
    \node [block] (lex) {Lexikálny analýzátor};
    \node [cloud, above=of lex, align=center] (zdroj) {Zdrojový\\program};
    \node [block, below=of lex, yshift=-1cm] (synta) {Syntaktický analyzátor};
    \node [block, right=of synta, xshift=3.0cm, align=center] (sema) {Sémantický\\analýzátor};
    \node [block, below=of synta, yshift=-1cm] (gen) {Generátor vnútorného kódu};
    \node [block, below=of gen] (opti) {Op\-ti\-ma\-li\-zá\-tor};
    \node [block, below=of opti, align=center] (gen_ciel) {Generátor cieľového kódu};
    \node [cloud, below=of gen_ciel, align=center] (ciel) {Cieľový\\program};
    
    \node [label, left=of synta, xshift=-0.75cm, yshift=0.5cm] (xlbl) {};
    
    \node [label, left=of synta, xshift=-1.4cm, yshift=0.5cm,align=center](lbl){Syntaxou\\riadený\\preklad};
    
    \node[draw,dashed, inner xsep=2em, inner ysep=2em, fit=(synta) (sema) (gen) (xlbl)] {};
    
    % Draw edges
    \path [line] (zdroj) -- (lex);
    
    \draw[->] (lex.230) -- node[near start, xshift=-1.25cm]{token} (synta.130);
    \draw[->] (synta.50) -- node[near end, xshift=2.25cm]{get\_token} (lex.310);
    
    \draw[->] (sema.163) -- node[yshift=0.5cm]{sémantická informácia} (synta.10);
    \draw[->] (synta.-10) -- node[]{sémantická kontrola} (sema.197.75);
    
    \path [line] (synta) -- node[]{generovanie inštrukcií} (gen);
    \path [line] (gen) -- node[]{vnútorný kód} (opti);
    \path [line] (opti) -- node[]{optimalizovaný kód} (gen_ciel);

    \path [line] (gen_ciel) -- (ciel);
    

\end{tikzpicture}
\caption{Schéma prekladača \cite{meduna}}
\label{fig:sch}
\end{center}
\end{figure}


\section{Lexikálny analyzátor}
\label{sec_lex}
Lexikálny analyzátor, scanner, má na vstupe zdrojový program. Tento program
rozdeľuje na lexémy - logicky oddelené lexikálne jednotky. Na výstupe je reťazec
tokenov, pričom token reprezentuje lexémy a môže obsahovať ďalšie atribúty.
Pre lepšie porozumenie viď obrázok \ref{fig:lex}.

\begin{center}
\begin{figure}
\begin{tikzpicture}[auto]

	\node [small_block] (s3) {y};
	\node[single arrow,draw=black,fill=white,minimum height=1cm, shape border rotate=-180, above=of s3] (ar1) {};	
	
    \node [block, above=of ar1] (first) {x = y * 2};
    \node [small_block, left=of s3] (s2) {=};
    \node [small_block, left=of s2] (s1) {x};


    \node [small_block, right=of s3] (s4) {*};
    \node [small_block, right=of s4] (s5) {2};  
	   
	   
	\node [data, below of=s1] (p1) {id \nodepart{second} x};    
	\node [data, below of=s2] (p2) {=};  
	\node [data, below of=s3] (p3) {id \nodepart{second} y};
	\node [data, below of=s4] (p4) {*}; 
	\node [data, below of=s5] (p5) {int \nodepart{second} 2};

	\node [label, left of=s1, xshift=-1cm] (t1) {Lexémy:};   
    \node [label, left of=p1, xshift=-1cm] (t2) {Tokeny:};  


\end{tikzpicture}
\caption{Schéma rozdeľovania na lexémy a tokeny}
\label{fig:lex}

\end{figure}
\end{center}


\section{Syntaktický analyzátor}
Syntaktický analyzátor, parser, má na vstupe reťazec tokenov, ktoré získal
z lexikálneho analyzátora. Úlohou je skontrolovať, či
reťazec tokenov reprezentuje syntakticky správne napísaný program. Táto kontrola
prebieha za pomoci konštrukcie derivačného stromu. Ak je možné zostrojiť derivačný strom
jedná sa o program validný. Konštrukcia môže prebiehať dvoma spôsobmi a to zhora
nadol a zdola nahor. \cite{meduna} 

\subsection{Analýza zhora-nadol}
Metóda zhora-nadol sa snaží skonštruovať derivačný strom od najvyššej úrovne a postupne prechádza derivačný strom dole za využita formálnych pravidiel gramatiky. To znamená, že derivačný strom sa konštruje od koreňa smerom k listom, zľava doprava, poďla ľavej derivácie. Syntaktická analýza zhora dole využíva pre svoju prácu LL syntaktické analyzátory. \cite{aho}

\subsection{Analýza zdola-nahor}
Metóda zdola-nahor sa snaží skonštruovať derivačný strom od najnižšej úrovne a postupne prechadza derivačný strom smerom ku koreni za využitia formálnych pravidiel gramatiky. To znamená, že sa najskôr identifikujú jednotlivé symboly z ktorých sa následne vytvára derivačný strom. Táto metóda využíva precedenčnú tabuľku. \cite{aho}

\section{Sémantický analyzátor}
Na vstupe sémantického analyzátoru je derivačný strom, ktorý bol získaný od
syntaktického analyzátora. Sémantický analyzátor kontroluje sémantické aspekty
vstupného programu a to hlavne 
\begin{itemize}
    \item kontrola typov
    \item kontrola deklarácií premenných
\end{itemize}
Na výstupe je abstraktný syntaktický strom.

\section{Generátor vnútorného kódu}
Generátor vnútorného kódu, ako názov napovedá, vytvára vnútornú reprezentáciu programu
z abstraktného syntaktického stromu. Medzi hlavné dôvody, prečo je vhodné
vytvárať vnútorný kód patrí hlavne:
\begin{itemize}
    \item Priame vytváranie výstupného programu je nepriehladné
    \item Jednotnosť - všetky inštrukcie sa tvária rovnako
    \item Jednoduchá optimalizácia
\end{itemize}

\section{Optimalizátor}
Cieľom tejto časti je upraviť vnútorný kód to takej podoby, aby bol efektívnejší.
Medzi optimalizácie môžu patriť:
\begin{itemize}
    \item Eliminácia mŕtveho kódu
    \item Šírenie kopírovaným
    \item Šírenie konštanty
\end{itemize}

\section{Generovanie cieľového kódu}
Optimalizovaný kód získaný z optimalizátora je prevedený na cieľový program.

\section{Syntaxou riadený preklad}
\label{sec_synta}
Jedná sa o prístup, keď celý prekladač je riadený procesom parsovania. Teda ku každému pravidlu gramatiky sú priradené ďalšie akcie, ktoré pokrývajú ostatné fázy prekladu. Medzi akcie môže napríklad patriť:
\begin{itemize}
    \item Vyvolanie sémantickej kontroly
    \item Ukladanie informácií napr. do tabuľky symbolov alebo tabuľky návestí
    \item Generovanie kódu
\end{itemize}
Prevažne pri využití tejto techniky postačuje jeden priechod cez zdrojový program.


\chapter{Súčasný stav prekladača pre ARTMC}
\label{kap_averiles}
Pre ARTMC bol vytvorený prekladač z jazyka C s názvom AVERILES. Jedná sa o
prekladač napísaný v jazyku Java. Snahou tejto práce nie je tento prekladač
upraviť ale napísať úplne nový. Hlavné dôvody prečo je potrebné vytvoriť nový
prekladač sú:
\begin{itemize}
    \item Chyby v prekladači\\
        Prekladač nedokázal spracovať určité výrazy. Niektoré výrazy prekladal nesprávne.
        Preto bolo potrebné pri zložitejších programoch manuálne kontrolovať výsledný
        program a editovať vstupný program do takej formy, aby ho prekladač dokázal
        preložiť.
    \item Tažko rozšíriteľný\\
        Prekladač bol napísaný v jazyku Java dosť zložitým a nečitateľným spôsobom. Takýto
        kód sa veľmi ťažko modifikuje a rozširuje o ďalšie vlastnosti. Prekladač,
        ktorý je výstupom tejto práce si dáva za cieľ čitateľný kód, do ktorého
        sa jednoducho dopĺňajú ďalšie funkcionality.
    \item Nepraktické používanie\\
        Proces prekladu za pomoci Averlis pozostáva z dvoch krokov
        \begin{enumerate}
            \item Tvorba XML zo zdrojového kódu v C
            \item Preklad XML do ARTMC
        \end{enumerate}
        Takýto postup je zložitejší, nakoľko je potrebné volať dva programy.
        Zároveň programy nemajú prepínače na modifikáciu ich správania. Teda
        ich použitie je možné len v jednom užívateľskom prípade
\end{itemize}

\chapter{Implementácia}
\label{kap_imp}
Táto kapitola sa venuje návrhu a implementácii samotného prekladača.
Ako implementačný jazyk bol zvolený Python. Kritériá, ktoré by mala výsledná
aplikácia spĺňať sa dajú rozdeliť do dvoch kategórií:
\begin{enumerate}
    \item Použiteľnosť a prenositeľnosť
    \item Moderný vývoj
\end{enumerate}

\section{Použiteľnosť a prenositeľnosť}
Výsledná aplikácia by mala byť jednoducho použiteľná. Tak ako bolo spomenuté v
kapitole \ref{kap_averiles}, momentálne existujúci prekladač má nie jednoduché používanie. Zároveň
neumožňuje špecifikovať ďalšie voľby, ktoré by užívateľ mohol potrebovať. Voľby,
ktoré by užívateľ mohol potrebovať mimo iné patria hlavne:
\begin{itemize}
    \item Možnosť špecifikovať výstupný súbor\\
        Implicitný výstupný súbor sa uloží na rovnaké miesto ako vstupný a je
        pomenovaný \texttt{program.py}. Avšak užívateľ si môže zvoliť ľubovoľné umiestenie
        a názov súboru.
    \item Možnosť špecifikovať vstupný deskriptor\\
        Viď kapitola \ref{kap_descr}. Nakoľko sa vstupný deskriptor získava z \texttt{get\_typedef\_descr.t.sh} a je
        možné, že tento program nie je dostupný, aby sa dal preklad spustiť, môže
        užívateľ túto hodnotu poskytnúť.
    \item Možnosť ignorácie dát\\
        Nakoľko podpora práce s dátami v ARTMC je výrazne obmedzená, môže byť
        vhodné nechať prekladač aby prácu s dátami neprekladal.
\end{itemize}

Rovnako medzi hlavné požiadavky patrí aj prenositeľnosť. V rámci prenositeľnosti
musíme uvažovať dva druhy:
\begin{itemize}
    \item Operačný systém\\
        Program by mal byť spustiteľný a správne bežať aspoň na Linux-och a Windows-och.
    \item Verzia Pythonu\\
        Program by mal byť spustiteľný a správne bežať na všetkých hlavných verziách Pythonu.
        Viac o Pythone a verziách je v kapitole \ref{subsec_python}.
\end{itemize}

\subsection{Python}
\label{subsec_python}
Python je vysokoúrovňový skriptovací programovací jazyk. Podporuje viacero programovacích
paradigmat. Pre túto prácu bude použité objektovo orientované. Zároveň Python podporuje
dynamickú typovú kontrolu. TODO more
Python má dve hlavné verzie. Python 2.X a Python 3.X. Ďalej tieto verzie sa delia na podverzie.
Verzie a podverzie nemusia (a ani nie sú) medzi sebou kompatibilné. To prináša problém
pre programátorov, ktorý chcú písať program tak, aby fungoval pre rôzne verzie.
C2ARTMC by mal fungovať aspoň pre verzie \texttt{2.6, 2.7, 3.3, 3.4, 3.5}.

\section{Moderný vývoj}
Táto časť sa venuje postupom a metódam, ktoré pri vývoji budú použité. Jedná sa
o prevažne o technológie, ktoré určujú kvalitný projekt v dnešnej dobe.

\subsection{Git}
Verzovací systém git umožňuje sledovať vývoj projektu a v jednotlivých zmenách
v histórií sa posúvať. Teda v prípade chyby je jednoduché zistiť kedy a ako chyba
vznikla. Zároveň je jednoduché sa vrátiť do stavu pred chybou.
Git umožňuje rovnako jednoduchú spoluprácu viacerých autorov. Táto práca je
prirodzene dielom jedného autora, avšak je možné, že po dokončení práce sa nájde
chyba, alebo bude treba doplniť funkcionalitu a to umožní aby iný autor túto zmenu
vykonal.
Táto práca využíva GitHub a je dostupná na \texttt{https://github.com/marusak/C2ARTMC}.

\subsection{Unittest}
Pri pridávaní novej funkcionality sa môže stať, že sa zavedie chyba vrámci inej
funkcionality. Preto je najvhodnejšie, po každej zmene otestovať všetky predtým
naprogramované funkcionality. To je prirodzene takmer nemožné. Preto sa píšu testy,
ktoré sa dajú spúšťať hromadne a je ľahko a rýchlo možné overiť, že neprišlo k
zavedeniu chyby.

\subsection{Tox}
Aby bolo možné spúšťať unittesty pod rôznymi verziami pythonu a overiť, že všetky testy
uspejú na všetkých podporovaných verziách Pythonu v práci bude použitý nástroj tox.
Jedná sa o program, ktorý potrebuje iba jeden jednoduchý konfiguračný súbor, ktorý
obsahuj spôsob ako sa spúšťajú unittesty a verzie Pythonov, pod ktorými chceme
aby program fungoval. Následne zavolaním programu tox bez argumentov sa testy
spustia pod všetkými požadovanými verziami a prehľadný výpis oznámi, či všetky
testy boli úspešné, prípadne ktorý test neuspel v ktorej verzii.


\chapter{Výsledná aplikácia}
Aplikácia bola vytvorená s ohľadom na zadanie bakalárskej práce. Boli dodržané všetky body zadania. Pri vývoji som sa držal požadovaných vlastností na kód a vývoj spomenutých v kapitole \ref{kap_imp}. Hneď po vytvorení prvej skutočne funkčnej časti kódu boli vytvárané automatické testy pre overenie skutočne fungujúcich implementovaných častí a overenie že počas pridávania novej funkcionality neprišlo k regresii v inej časti kódu. 

Kód bol od začiatku publikovaný na GitHub-e s ohľadom na odporúčané praktiky pri využívaní verzovacieho systému git. História je prehľadná a je možné v nej jednoducho sa vracať alebo zisťovať ktorá časť kódu bola kedy implementovaná.

Výsledný program bol poriadne otestovaný na veľkej sade testov. Všetky testy prešli úspešne na všetkých požadovaných operačných systémoch ako aj verziách Pythonu.

\section{Výsledná implementácia}
V tejto časti textu je popis implementácie. Jedná sa o spojenie znalostí z kapitoly \ref{kap_prekladace} o prekladačoch so skutočne použitými vlastnosťami a ich implementáciou v jazyku Python.
\subsection{Lexikálny analyzátor}
Ako prvá časť bol implementovaný lexikálny analyzátor. Jedná sa o samotnú triedu \texttt{Scanner}, ktorá v inicializácii berie názov súboru z programom v jazyku C. Následne je vstupný program načítaný a predspracovaný. Jedná sa hlavne o odstránenie komentárov a nahradenie skupín bielych znakov jednou medzerou. Tieto úpravy následne umožňujú jednoduchšie delenie kódu na tokeny. Trieda lexikálneho analyzátora poskytuje metódu \texttt{get\_token}, ktorá vráti práve jeden token. Na delenie sa nevyužívajú regulárne výrazy, ale podľa prvého neprečítaného znaku sa scanner rozhoduje o aký token sa môže jednať. Následne po rozpoznaní tokenu, je vrátený token, ktorý je reprezentovaný jedným číslom - jedná sa o imitáciu \texttt{enum} pre jazyk Python. Konkrétna hodnota tokenu sa nevracia priamo a je možné ju získať volaním funkcie \texttt{get\_value}. Scanner poskytuje aj metódu \texttt{unget\_token}, ktorá vráti jeden token späť do vstupného reťazca. Nakoľko je ale scanner ako aj celý prekladač jednopriechodový, je táto funkcia implementovaná inštančnou premennou, ktorá drží vrátenú hodnotu. Výhodou je jednoduchá implementácia, nevýhodou je možné vrátiť iba jeden token.

\subsection{Syntaktický analyzátor}
Následne bol tvorený syntaktický analyzátor, ktorý je implementovaný ako trieda \texttt{Parser}. Jedná sa o syntaxou riadený preklad a preto je samotný analyzátor najdlhšia časť kódu. Napriek svojej veľkosti sa jedná o pomerne jednoduchý program. V princípe je celá analýza jeden while cyklus, ktorý čaká až skončí vstupný súbor a scanner vráti EOF. V tomto cykle sa prečíta prvý token a sa rozhodne o aký príkaz sa jedná. V tejto úrovni sa môže jednať iba o definíciu alebo deklaráciu funkcie alebo premennej. Spracovanie premennej je priamočiara záležitosť. Spracovanie funkcie obsluhuje funkcia \texttt{parse\_function}, ktorá je obdobne jeden while cyklus, ktorý volá funkciu \texttt{parse\_command} až pokiaľ nenarazí na ukončujúcu zloženú zátvorku. Funkcia \texttt{parse\_command}
na základe prvého tokenu zavolá funkcie na spracovanie príkazu, napríklad \texttt{parse\_if} alebo \texttt{parse\_assignment}. Ak sa jedná o príkaz, ktorý vytvára ďalšiu úroveň zanorenia ako napríklad \texttt{if} alebo \texttt{while}, celá úroveň je spracovaná touto funkciou za volania  \texttt{parse\_command} na spracovanie jednotlivých príkazov. Hovoríme teda o rekurzívnom zanorovaní.

Ako bolo spomenuté v sekcii \ref{sec_synta} ohľadom syntaxou riadenom preklade, počas syntaktickej analýzy sa vykonávajú aj ďalšie akcie. Medzi takéto akcie patrí napríklad vloženie premennej do tabuľky symbolov po nájdení novej premennej. Tabuľku symbolov vlastní trieda \texttt{Parser} a poskytuje sadu inštrukcií na prácu s ňou. Medzi ďalšie akcie patrí vygenerovanie inštrukcie vo vnútornom kóde po prečítaní celého príkazu. 

\subsection{Sémantický analyzátor}
Sémantický analyzátor nie je implicitne oddelený od zvyšku kódu ako je napríklad lexikálny alebo syntaktický analyzátor. Sémantická analýza sa vykonáva len v tak obmedzenej forme, že všetky potrebné kontroly boli priamo zahrnuté do parsera. Hlavný dôvod je málo kontrol súvisiaci s nepodporovaním dát v jazyku ARTMC a teda takmer všetky inštrukcie, kde je potrebná sémantická analýza sa nevyskytujú vo vstupnom súbore. Je prirodzene ošetrené aj správanie v prípade výskytu takejto konštrukcie. To je popísané v sekcii \ref{sec_features}.

\subsection{Generovanie kódu}
Na spracovanie vnútorného kódu bola vytvorená trieda \texttt{Generate}. Tento názov napovedá, že trieda nie len že príma od parseru inštrukcie vo vnútornej reprezentácií, ale aj generuje cieľový kód. Trieda poskytuje celú radu funkcií pre vkladanie inštrukcií, ktoré začínajú prefixom \texttt{new\_i\_}. Okrem toho obsahuje funkciu \texttt{get\_full\_result}, ktorá má za úlohu vrátiť kód vo výstupnom jazyku pripravený na výpis alebo zápis do súboru. Táto funkcia volá všetky potrebné funkcie na generovanie a dokončovanie inštrukcií z vnútorného kódu do výsledného kódu.

Schéma fungovania výslednej implementácie je znázornená na obrázku \ref{fig:imp}.

\begin{center}
\begin{figure}[h]
\begin{tikzpicture}[auto,>=latex']

    \node [cloud, align=center] (vstup) {Vstupný\\program};
    \node [block, right=of vstup, xshift=1.5cm] (c2artmc) {c2artmc.py};
    \node [cloud, right=of c2artmc, align=center, xshift=3cm] (vystup) {Výstupný\\program};
    
    \node [block, below=of vystup, xshift=-1.75cm] (generate) {Generate};


    \path [line] (vstup) -- (c2artmc);

    \draw [->] (c2artmc.20) -- (vystup.160);
    \draw [->] (c2artmc.280) |- node[near start]{init} (generate.170);
    \draw [->] (c2artmc.-20) -| node[near start, yshift=-0.75cm, xshift=-0.25cm]{get\_full\_result} (generate.110);
    \draw [->, dashed] (generate.70) |- node[near start, xshift=3.5cm, yshift=-0.5cm]{výstupný program}  (c2artmc);
    
    \node [block, below=of vstup, xshift=1.75cm] (parser) {Parser};
    \draw [->] (c2artmc.260) |- node[near end]{init} (parser);
    \draw [->] (c2artmc.240) |- node[near end]{run} (parser.20);
    \draw [->] (parser.-20) |- node[near end, yshift=-0.5cm]{new\_i\_<insturction>}  (generate.200);
    
    
    \node [block, below=of parser, yshift=-1.5cm] (scanner) {Scanner};
    \draw [->] (parser.218) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{init} (scanner.142);
    \draw [->] (parser.240) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{get\_token} (scanner.120);
    \draw [->] (parser.275) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{unget\_token} (scanner.85);
    
        \draw [->, dashed] (scanner.50) -- node[near start, rotate=-90, yshift=-0.16cm, xshift=-0.5cm]{token} (parser.310);



\end{tikzpicture}
\caption{Schéma fungovania implementovaného prekladača}
\label{fig:imp}

\end{figure}
\end{center}


\section{Vstupný program}
Na vstupe sa očakáva platný program v jazyku C s určitými výnimkami. Výnimky môžme rozdeliť na štyri skupiny:\\
\begin{enumerate}
\item Nepodporované konštrukcie
\item Neštandardné podporované konštrukcie
\item Povinné položky
\item Nepovinné položky
\end{enumerate}

\subsection{Nepodporované konštrukcie}
Ako bolo spomenuté v kapitole \ref{kap_artmc}, nástroj ARTMC má obmedzenú sadu príkazov a preto nie je možné preložiť ľubovoľné konštrukcie. Avšak prekladač bol implementovaný tak, aby nebolo nutné program príliš upravovať. Je to dosiahnuté tým, že príkazy, ktoré nemenia používané premenné sú preskočené. Viac o tejto vlastnosti je v sekcii \ref{sec_features}.

Z významných konštrukcií nie sú podporované:
\begin{itemize}
\item \texttt{enum}
\item \texttt{for}
\item \texttt{union}
\end{itemize}

Medzi významné nepodporované konštrukcie patrí aj obmedzenie prác s dátami. Tomuto obmedzeniu sa venuje sekcia \ref{sec_data}.

\subsection{Neštandardné podporované konštrukcie}
Okrem validných konštrukcií pre jazyk C boli implementované aj rozšírenia, ktoré sú potrebné pre nástroj ARTMC. Jedná sa hlavne o podporu nedeterministického rozhodovania. V jazyku C je túto konštrukciu možné zapísať ako \texttt{if(*)} alebo \texttt{if(any)}. Obe tieto konštrukcie sa preložia na príkaz \texttt{if*}.

Bola implementovaná podpora aj pre kľúčové slovo \texttt{ERROR}, ktoré sa môže vyskytnúť vrámci vrámci príkazu \texttt{return}. Tento príkaz sa preloží na príkaz \texttt{goto}. Ako miesto skoku je riadok vyskytujúci sa v \texttt{env} \texttt{err\_line}. Príkaz \texttt{return ERROR} sa môže chápať ako ukončenie s chybou, napríklad po neúspešnom mallokovaní pamäte.

Posledná neštandardná vlastnosť pre implementovaný prekladač je podpora funkcie \texttt{random\_alloc(void)}. Táto funkcia sa preloží na príkaz \texttt{random\_position}. Využitím tejto funkcie je možné prinútiť nástroj ARTMC vybrať náhodný alokovaný uzol.

\subsection{Povinné položky}
Nástroj ARTMC defaultne predpokladá existenciu akejsi špecifickej štruktúry. Avšak počas návrhu prekladača bolo rozhodnuté, že prekladač nebude implicitne predpokladať existenciu žiadnej dátovej štruktúry a bude vyžadovať, aby vždy bola presne zadaná pre každý program. Preto vstupný program musí obsahovať presne definovanú štruktúru. Príkladom môže byť štruktúra v schéme \ref{fig:struct}. Za povšimnutie stojí existencia iba jednej neukazateľovej položky. Viac ako jedna dátová položka totižto nie je podporovaná zo strany nástroja ARTMC a teda takúto štruktúru prekladač odmietne.

\begin{center}
\begin{figure}
\texttt{
typedef struct T1 \{\\                                                            
\tab struct T1* next;\\                                                            
\tab struct T1* prev;\\                                                          
\tab int data;\\                                                                   
\}* T;
}

\label{fig:struct}
\caption{Vzorový príklad štruktúry vo vstupnom programe}
\end{figure}
\end{center}

\subsection{Nepovinné položky}
Prekladač nepodporuje direktívu preprocesoru \texttt{\#include}. Avšak takéto riadky sú pri preklade ignorované, takže je možné ich tam nechať. Preto je riadok \texttt{\#include <xxxxxx.h>} nepovinný aj napriek tomu, že v zdrojovom kóde sa môžu vyskytovať kľúčové slová a funkcie ktorú sú touto knižnicou podporované. V tabuľke \ref{table:kniz} je výpis knižníc a príkazov, ktoré z nich sú podporované.

\begin{table}[]
\centering
\caption{Implicitne podporované príkazy}
\label{table:kniz}
\begin{tabular}{|c|l|}
\hline
\textbf{Knižnica} & \textbf{Kľúčové slová a  funkcie} \\ \hline
stdlib.h          & NULL, malloc                      \\ \hline
assert.h          & assert                            \\ \hline
stdbool.h         & true, false                       \\ \hline
\end{tabular}
\end{table}


\section{Práca s dátami}
\label{sec_data}
Vo vstupnom súbore nie sú podporované operácie nad dátovými premennými okrem priradenia a porovnania. Je možné len jedno priradenie a následne nie je možné hodnotu meniť. Na takúto situáciu prekladač upozorní. Avšak je možné preložiť aj takýto program za pomoci ignorovania práce s dátami.

\subsection{Ignorovanie dát}
Počas vývoja a testovania prekladača sa vyskytol problém pri práci s dátami. Na vstupe sa mohol objaviť validný program, ktorý mohol by korektne preložený avšak kvôli čo i len jednému príkazu manipulujúcim s dátovou premennou nemohol byť tento program preložený. Často sa jednalo o prácu s premennou, ktorá nebola nijak potrebná pre analýzu nástrojom ARTMC. Ako príklad uvádzam nasledujúci program:\\

\noindent
\texttt{
\tab x->data = 1;\\
\tab \dots\\
\tab x->data *= 2;\\
\tab \dots \\
\tab \textit{ manipuluje sa s x->data }\\
\tab \dots\\
\tab if (x->data < 0)\\
\tab \tab x->next = y;\\
}

V horeuvedenom programe sa manipuluje s dátovou položkou štruktúry. Takéto operácie nie sú podporované zo strany nástroja ARTMC a preto by tento program nemohol byť preložený. Avšak ak používateľ prekladača uzná, že tieto manipulácie a podmienka nie je kritickým rozhodovacím miestom a teda vynechanie zmien dátovej položky a nahradenie podmienky za nedeterministickú je možné, môže použiť prepínač \texttt{-i}, ktorý vynúti neprekladanie všetkých operácií, ktoré manipulujú s dátami a všetky podmienky obsahujúce porovnávanie dátové položky sa zmenia na nedeterministickú podmienku \texttt{if*}.

\subsection{Konštanty}
Okrem podpory priameho priraďovania dát do dátovej položky štruktúry je možné použiť priradenie aj zo štandardnej dátovej položky. Príklad použitia je znázornení na nasledujúcom kuse kódu:\\

\noindent
\texttt{
\tab int i = 0;\\
\tab x->data = i;\\
}

Obdobne je možné použiť štandardnú dátovú premennú aj v podmienke ako je vidieť v nasledujúcej ukážke:\\

\noindent
\texttt{
\tab int i = 0;\\
\tab x->data = 1;\\
\tab if (x->data == i)\\
\tab \tab return ERROR;\\
}

Avšak rovnako ako pri práci s dátami priamo, ani v tomto prípade nie je možné meniť hodnotu premennej. Preto takúto premennú môžme považovať za konštantu.

\section{Použitie aplikácie}
Prekladač poskytuje viacero prepínačov, ktorými je možné upraviť implicitné správanie.  Nasleduje výpis \texttt{c2artmc.py --help}, ktorý ukazuje možné použitie tohto nástroja.
\begin{verbatim}
usage: c2artmc.py [-h] [-o O] [-d D] [-i] INPUT_FILE

Converter from C to ARTMC.

positional arguments:
 INPUT_FILE  C source file to be converted

optional arguments:
  -h, --help  show this help message and exit
  -o O        Filepath to write the ARTMC file
  -d D        Initial pointer descriptor
  -i          Ignore data
\end{verbatim}

\section{Neštandardné vlastnosti}
\label{sec_features}
V tejto kapitole sú popísané vybrané vlastnosti prekladača, ktoré sú navrch zadania a implementujú užitočné vlastnosti.
\subsection{Preskakovanie (častí) príkazov}
Nakoľko nástroj ARTMC neobsahuje žiadnu podporu pre volanie funkcií je nutné byť schopný adekvátne zareagovať na výskyt volania funkcie. Riešením je ohlásiť chybu pri nájdení volania funkcie. Avšak počas testovania sa ukázalo, že výhodnejšie je priamo takéto príkazy preskakovať. Preto bol na to aj prekladač upravený. Momentálne prekladač upozorní na fakt, že sa volanie funkcie preskakuje. Očakáva sa od používateľa, že na tieto varovania zareaguje a ak niektorá funkcia menila premenné podstatné pre analýzu tak tieto príkazy adekvátne upraví.

Prekladač rovnako preskakuje aj časti príkazov, ak dopredu vie, že nesledujúcu informáciu nepotrebuje. Jedná sa napríklad o príkaz \texttt{return}. Ak sa za príkazom \texttt{return} nevyskytuje kľúčové slovo \texttt{ERROR} tak prekladač môže zahodiť zvyšok príkazu. Obdobne to funguje aj pri funkciách \texttt{malloc} a \texttt{random\_alloc} kde ich argumenty sú neprekladané.

\subsection{Preklad viacnásobných pointrov}
V prekladači je implementovaná podpora pre preklad viacnásobného prístupu cez ukazateľ či sa už jedná o zápis alebo čítanie. Je teda možné preložiť príkaz typu:\\

\noindent
\texttt{
x->next->next = y->prev->next->prev;\\
}

Nakoľko nástroj ARTMC nemá podporu pre takýto prístup, je nutné príkaz rozdeliť na viacero jednoduchých prístupov. Vyššie uvedený program by sa teda dal za pomoci pomocných premenných napísať ako:\\

\noindent
\texttt{
tmp1 = x->next;\\
tmp2 = y->prev;\\
tmp3 = tmp2->next;\\
tmp4 = tmp3->prev;\\
tmp1->next=tmp4;\\
}

čo už je možné preložiť aj do nástroja ARTMC.

\subsection{Vyhodnocovanie neúplných podmienok}

TODO if (x), if (x->data)

\subsection{Skratové vyhodnocovanie podmienok}
V jazyku C je zaužívané využívať skratové vyhodnocovanie podmienok pre jednoduchší zápis. Veľmi často sa tento prístup používa práve pri dynamicky viazaných dátových štruktúrach. Pre lepšie porozumenie uveďme príklad:\\

\noindent
\texttt{
if (x \&\& x->next)\{\\
\tab x->next->next = y;\\
\}\\
}

Pri tomto zápise máme istotu, že nepristúpime alebo nezapíšeme do nealokovaného uzla, nakoľko sa najskôr overí, že je  alokované \texttt{x} a ak je tak potom \texttt{x->next}. A iba ak oba uzly sú alokované, môžme bezpečne zapísať aj do \texttt{x->next->next}.

Implementovaný prekladač dokáže takéto podmienky preložiť. Je k tomu použitý relatívne jednoduchý algoritmus, ktorý rozdelí výraz na podvýrazy oddelené skupinami logických operátorov. Následne sa prechádza cez skupiny \texttt{or}-ov a \texttt{and}-ov. Pre skupinu podvýrazov oddelených \texttt{||} platí, že po úspechu jednotlivých podvýrazov sa pokračuje za posledným podvýrazom v skupine a pri neúspechu nasledujúcim. Pri skupine spojenej logickým operátorom \texttt{\&\&} je to presne naopak. Tento algoritmus je znázornený na obrázku \ref{fig:scrat} kde čiarkovane sú označené podvýrazy, bodkovane skupiny, plnou šípkou splnenie podmienky a čiarkovanou šípkou nesplnenie.

\begin{center}
\begin{figure}[h]
\begin{tikzpicture}[auto,>=latex', node distance=1mm]

    \node [subexpression] (t1) {p1};
    \node [operand, right=of t1] (l1) {\&\&};
    \node [subexpression, right=of l1] (t2) {p2};
    \node [operand, right=of t2] (l2) {\&\&};
    \node [subexpression, right=of l2] (t3) {p3};
    \node [draw,dotted, ellipse, inner xsep=-2.25em, fit=(t1) (l1) (t2) (l2) (t3)] {};
    
	\draw [->] (t1) to [out=30,in=150] (t2);
	\draw [->] (t2) to [out=30,in=150] (t3);


    \node [operand, right=of t3] (l3) {||};
    \node [subexpression, right=of l3] (t4) {p4};
    \node [operand, right=of t4] (l4) {||};
    \node [subexpression, right=of l4] (t5) {p5};
    \node [draw,dotted, ellipse, inner xsep=-1.25em, inner ysep=0em, fit=(l3) (t4) (l4) (t5)] {};    
    \draw [->,dashed] (t3) to [out=30,in=150] (t4);
    \draw [->,dashed] (t1) to [out=45,in=135] (t4);
    \draw [->,dashed] (t2) to [out=45,in=140] (t4);
    

    \node [operand, right=of t5] (l5) {\&\&};
    \node [subexpression, right=of l5] (t6) {p6};
    
     \node [draw,dotted, ellipse, inner xsep=-0.75em, inner ysep=0em, fit=(l5) (t6)] {}; 
     \draw [->] (t3) to [out=315,in=240] (t6);
     \draw [->] (t4) to [out=315,in=230] (t6);
     \draw [->,dashed] (t4) to [out=30,in=150] (t5);
     
     \node [subexpression, right=of t6, fill=black!30, yshift=-1cm] (T) {True};
     \node [subexpression, right=of t6, fill=black!30, yshift=1cm] (F) {False};
     
     \draw [->,dashed] (t5) to [out=30,in=180] (F);
     \draw [->] (t5) to [out=315,in=220] (t6);
     
     \draw [->,dashed] (t6) to [out=10,in=270] (F);
     \draw [->] (t6) to [out=-10,in=90] (T);
     
     

    

\end{tikzpicture}
\caption{Schéma fungovania prekladu skratového vyhodnocovania}
\label{fig:scrat}

\end{figure}
\end{center}




\section{Testy}
TODO

\section{Nedostatky a známe chyby}
Vo výslednej aplikácií nie sú žiadne známe chyby a všetky požiadavky boli implementované.

\section{Navrhovaná práca}
Všetky požadované vlastnosti pre výslednú aplikáciu boli implementované. Avšak je možné, že časom si používanie ARTMC bude vyžadovať ďalšie funkcie, napríklad nové konštrukcie z jazyka C a teda bude potrebné daný kód doplniť. 

\chapter{Záver}
TODO
%=========================================================================
